{
  "hash": "873f2be55992160d1e439049842f149a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"From MODIS to VIIRS: The Latest Source for NDVI Data\"\ndescription: \"Update your NDVI workflows with NASA's newest instruments\"\nauthor: \n  - name: \"Finn Roberts\"\n    affiliation: \"IPUMS Senior Data Analyst\"\n  - name: \"Rebecca Luttinen\"\n    affiliation: \"IPUMS Global Health Data Analyst\"\ndate: 03-31-2025\ncategories:\n  - NDVI\n  - VIIRS\n  - MODIS\n  - NASA\n  - Agriculture\n  - Food production\n  - Importing Data\n  - R\n  - Reproducible workflows\n  - terra\n  - rhdf5\n  - stringr\n  - purrr\n  - ggspatial\nfig-width: 10\nfig-height: 8\nbibliography: references.bib\nimage: index_files/figure-html/listing-img-1.png\nopen-graph:\n  title: \"From MODIS to VIIRS: The Latest Source for NDVI Data\"\n  description: \"Update your NDVI workflows with NASA's newest instruments\"\n  image: index_files/figure-html/listing-img-1.png\ntwitter-card:\n  title: \"From MODIS to VIIRS: The Latest Source for NDVI Data\"\n  description: \"Update your NDVI workflows with NASA's newest instruments\"\n  image: index_files/figure-html/listing-img-1.png\n---\n\n::: {.cell}\n\n:::\n\n\n\nThe Normalized Vegetation Index (NDVI) is a measure that can be used in \nresearch involving climate patterns, agriculture, access to green space and \nmuch more. We’ve introduced NDVI in a [previous post](../2024-08-01-ndvi-data), \nwhere we downloaded and \nprepared NDVI data from MODIS.\n\n[MODIS](https://modis.gsfc.nasa.gov/), or the Moderate Resolution Imaging \nSpectroradiometer, is a global \nimager on two satellites (Terra and Aqua) that has collected images of Earth’s \nsurface for more than 20 years. While originally designed with the expectation \nof a 5-year lifespan, MODIS is still operating today. However, as we \n[mentioned](../2024-08-01-ndvi-data/#obtaining-ndvi) previously, both \nTerra and Aqua are set to be \n[decommissioned](https://www.earthdata.nasa.gov/news/feature-articles/from-terra-terra-firma). As they drift from their original orbits, their overpass times\nwill increasingly lag, making the data they collect more difficult to \ncompare over time. \nTerra will continue to collect data \nuntil December 2025, while Aqua will remain in orbit until August 2026.\n\nFortunately, a new imaging instrument has already been launched: the \n[Visible Infrared Imaging Radiometer Suite](https://www.earthdata.nasa.gov/data/instruments/viirs) \n(VIIRS). In this post, we'll adapt the workflows we introduced before \nusing MODIS data with a new workflow using VIIRS data.\n\n# MODIS vs. VIIRS\n\nFortunately, given the importance of MODIS in many earth science and observation\napplications, significant effort has been put into ensuring continuity between \nMODIS and VIIRS to ease the transition between the two \ninstruments.[@Roman2024; @Skakun2018]\nStill, there are some differences between the two products.\n\nPerhaps most importantly, of course, is difference in temporal availability \nbetween the two. VIIRS data is only available starting in 2012, \nwhile MODIS data are available all the way back to early 2000. Thus, if you’re \nlinking environmental data to historical survey records, you may have no choice \nbut to use MODIS data. Fortunately, research suggests that you can use \ndata from the two instruments together if your timeframe of interest \noverlaps the transition from MODIS to VIIRS.[@Roman2024; @Li2014; @Skakun2018]\n\n::: {.aside}\nFor use before 2000, you may need to look into the [Advanced Very High \nResolution Radiometer](https://www.earthdata.nasa.gov/data/instruments/avhrr)\n(AVHRR).\n:::\n\nVIIRS and MODIS also have different spectral bands. MODIS has 36 spectral bands \nranging from 250m to 1km in resolution, while VIIRS has 22 spectral bands at \n375m and 750m. Some, though \nnot all, of the VIIRS spectral bands have higher resolution than their \nanalogous MODIS bands.[@Roman2024] So, while VIIRS does use more current\ntechnology and improves upon MODIS in detection and accuracy for certain\nwavelengths of light, there are specific bands where MODIS provides higher\nresolution.\n\n::: {.callout-tip}\nA spectral **band** refers to a specific range of light wavelengths that are \ndetected by the imaging sensor. The reflectance of the surface in different\nbands can be used to calculate many remote sensing metrics. NDVI, for instance,\nis calculated using both the near-infrared band reflectance and the red band\nreflectance.\n:::\n\nFurther, while MODIS data was collected both in the morning and in the \nafternoon, VIIRS only provides afternoon data. This means that diurnal \ncomparisons are not possible using VIIRS, and observations for areas that \ntend to have cloud cover during the afternoon may be more difficult.\n\nSee Román et al. (2024)[@Roman2024] for more detailed technical comparisons between the\ntwo instruments. The \n[VIIRS vegetation index technical documentation](https://viirsland.gsfc.nasa.gov/PDF/SNPP_VIIRS_VI_UserGuide_09-26-2017_KDidan.pdf) \nis also\na comprehensive resource for understanding how VIIRS vegetation data\nis collected and processed.\n\n# Obtaining VIIRS NDVI data\n\nYou can obtain VIIRS data through NASA's \n[Earthdata Search](https://search.earthdata.nasa.gov/search)\ninterface, just like we \n[previously demonstrated](../2024-08-01-ndvi-data/#earthdata-search) when \nexplaining how to\ndownload data from MODIS. All you need to do is update the data collection you\nsearch for to identify VIIRS data products rather than MODIS data products.\n\nIn our previous post, we used the MOD13Q1 collection—250m \nresolution data delivered in 16-day increments. In this section, we'll \ndemonstrate how to obtain coarser global vegetation data from VIIRS.\n\n## Why coarse resolution data?\n\nJust like MODIS, VIIRS provides several different spatial and temporal \nresolution options.\n\nWhile it may seem obvious that you'd always want to find the highest\nresolution data available, this isn't always the case. Particularly when\nlinking environmental data to large-scale surveys as we've demonstrated \nthroughout this blog, the limiting factor on our precision is typically \nthe location data available in the *survey*, not the \nenvironmental data. Essentially, because\nof the inherent uncertainty in our survey locations, the benefit of highly\ndetailed environmental data is lost.\n\nIn many cases, NASA will provide data products that have already been aggregated\nboth spatially and temporally. These data are often easier to work with and\nsmaller in size, and the aggregation methods that NASA uses often do a better\njob of handling data quality issues than we could do when aggregating ourselves.\n\nThat being said, there are certainly cases where it's worthwhile to obtain\nhigher-resolution data. This may be the case if you have a high degree of spatial\nresolution in the data you're linking to the environmental metrics, or if you\nwant to aggregate data in a particular way to calculate environmental\nmetrics that NASA doesn't provide out of the box (see \nour [CHIRTS heatwave post](../2024-04-15-chirts-metrics/#days-above) for an \nexample).\n\nThe key is that when coarse resolution data are sufficient—as they often \nare—they're typically the best option.\n\n### VIIRS global data: VNP13C2\n\nIn the Earthdata Search interface, the product we'll use has the code \n**VNP13C2**. \n\n**VNP** is the prefix used for products that use the VIIRS instrument aboard\nthe NPP (as opposed to\n**MOD**, which we used for Terra-based MODIS products). \n\n::: {.callout-note}\nNPP refers to the\n[Suomi National Polar-orbiting Partnership](https://eospso.nasa.gov/missions/suomi-national-polar-orbiting-partnership), \na satellite launched in 2011 with VIIRS (and other instruments) on board. The newer [Joint\nPolar Satellite System](https://eospso.nasa.gov/missions/joint-polar-satellite-system-1) \n(JPSS-1) also houses VIIRS instruments (with the code VJ1).\n\nWe're using data from 2014 in this demo for consistency with our previous post\non MODIS. However, if you're working with data more recent than 2017, you \nlikely will want to use JPSS-1 VIIRS data.\n:::\n\nThe **13** \ncomponent of the\ncollection name is a code that indicates that the collection is a vegetation \nindex.\n\nThe spatial resolution is represented by the final 2 digits of the collection\ncode. In this case we'll use **C2**, which is the coarsest data available from \nVIIRS (~5.5 km) and is delivered globally. This and other global data products\nare provided on the **Climate Modeling Grid**, or CMG, in which data are\nin geographic (latitude and longitude) coordinates (this will be important\nlater!).\n\nTo find the VNP13C2 product, enter the \ncode in the search bar on the Earthdata Search interface.\n\nYou should see a few different collections that pop up. We'll want to use the\n**latest version** of the data. NASA regularly makes improvements and corrections\nto the data from its instruments, and importantly these changes are \n**retroactively applied** to prior years of data. Thus, it's always advisable to\nuse the latest version of a data product once it's released. At the time of\nwriting, the latest version is v002, so we'll select the \n\"VIIRS/NPP Vegetation Indices Monthly L3 Global 0.05Deg CMG V002\" collection.\n\n::: column-page\n![](images/earthdata_viirs1.png)\n:::\n\nFrom here, you can follow the \n[instructions](../2024-08-01-ndvi-data/#earthdata-search) we introduced in our previous\npost (or use the Earthdata Search walk-through available when you launch the\nwebsite) to narrow down your temporal range of interest. Here, our data are\nglobal, but if you were working with a higher resolution dataset, you could\nalso select data for a specific spatial region through this interface as well.\n\nWe've restricted our data to the first three months of 2014 for demonstration.\nYou can download the data by clicking **Download All**.\n\n::: column-page\n![](images/earthdata_viirs2.png)\n:::\n\nWe've placed these VNP13C2 files in a `data/VNP13C2` directory, which we'll\nuse for the rest of the post.\n\n# Loading VIIRS data into R\n\nAs always, we'll start by loading the packages we'll use in this demo.\n\n<!-- Note that this was run under terra 1.8.29 -->\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(ggspatial)\nlibrary(purrr)\nlibrary(terra)\n```\n:::\n\n\n\nIn large part, loading VIIRS data follows the same workflow that we \n[demonstrated](../2024-08-01-ndvi-data/#nasa-image-files)\nfor MODIS data. Both data sources are raster data containing the same vegetation\nindices.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- list.files(\"data/VNP13C2\", full.names = TRUE)\n```\n:::\n\n\n\nThe file names contain helpful information about the data within. We can see the \nVIIRS product code (VNP13C2) followed by the\nfile timestamp (e.g., A2014001), which uses the year (2014) followed by the \nJulian day (001—for January 1st). \nWe also see the version (002) and finally the time that the file was last\nprocessed by NASA.\n\n\n\n::: {.cell scrub_data_local='true'}\n\n```{.r .cell-code}\nfiles\n#> [1] \"data/VNP13C2/VNP13C2.A2014001.002.2024060013808.h5\"\n#> [2] \"data/VNP13C2/VNP13C2.A2014032.002.2024060030203.h5\"\n#> [3] \"data/VNP13C2/VNP13C2.A2014060.002.2024060044137.h5\"\n```\n:::\n\n\n\nOne key difference is in the file format. While the MODIS files we downloaded\npreviously came in HDF4 format, VIIRS files come in HDF5 (`.h5`) format. HDF5\nfiles are supported by `{terra}`, but they store their metadata in different\nways, which are not always detected automatically.\n\nFor instance, if we load a few sample VIIRS files that we downloaded as described\nabove, we notice that we get a warning when attempting to load with\n`rast()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_cmg <- rast(files)\n#> Warning: [rast] unknown extent\n```\n:::\n\n\n\nThis warning is alerting us to the fact that while we were able to load the\nfile into a `SpatRaster` object, we're missing information about the spatial\nextent of the data we've loaded.\n\nWe can check the extent information with `ext()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\next(viirs_cmg)\n#> SpatExtent : 0, 7200, 0, 3600 (xmin, xmax, ymin, ymax)\n```\n:::\n\n\n\nWhy do we have extent information stored when terra warned us that it couldn't\nidentify the extent? This is because the extent that's used in the absence\nof geographical information is simply in *pixel units*. That is, our raster is \n7200x3600 pixels.\n\nUnfortunately, this doesn't tell us anything about the geographic locations\nthat the data correspond to. That is, the data aren't **georeferenced**.\n\nAccordingly, we'll notice that our data are also missing a coordinate reference\nsystem:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(viirs_cmg)\n#> [1] \"\"\n```\n:::\n\n\n\nSo, terra was able to load the raster values, but we don't know any of the\ncritical geographical information associated with these data. Apparently\nterra isn't able to access it in these files!\n\n:::{.callout-note}\nWhile these metadata aren't loaded automatically at the time of\nwriting, it's possible that future updates to these files, `{terra}` or other\nR packages may make it possible to do so, and you may not need to manually\nfix the raster metadata after loading as we demonstrate below.\n:::\n\n## Fixing raster metadata\n\nAs stated in the [VIIRS Vegetation Index Product Guide](https://viirsland.gsfc.nasa.gov/PDF/SNPP_VIIRS_VI_UserGuide_09-26-2017_KDidan.pdf), \nthe VIIRS CMG data are provided in WGS84 geographic coordinates\n(that is, latitude and longitude) for the entire globe.\n\nWe could use this knowledge to provide the missing extent and CRS information\nourselves. We know that the global extent should span from -180°\nto 180° in longitude and -90° to 90° in latitude, so we can easily set the\nextent using terra's `ext()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note that `ext()` expects coordinates in (xmin, xmax, ymin, ymax) order\next(viirs_cmg) <- c(-180, 180, -90, 90)\n```\n:::\n\n\n\nSimilarly, we could provide the [EPSG code](https://epsg.io/) for WGS84 using\nterra's `crs()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(viirs_cmg) <- \"epsg:4326\"\n```\n:::\n\n\n\nUnfortunately, if we go ahead and plot our data, we notice something a bit\nunexpected:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(viirs_cmg[[1]])\n```\n:::\n\n::: {.cell .column-page}\n::: {.cell-output-display}\n![](images/global-map-1.png){width=100%}\n:::\n:::\n\n\n\nAs it turns out, because of the lack of geographic metadata, the file was\nflagged as \"flipped\" by [GDAL](https://gdal.org/en/stable/) (the spatial\ntranslation library used by terra), so terra flipped the file vertically.\nWhen loading our raster, we can set `noflip = TRUE` to ensure our data are\nloaded in the correct orientation.\n\nYou may also have noticed that the range of values in the plot above doesn't\ncorrespond to what we'd expect from NDVI (which should range from -1 to 1). This\nis because our input file actually contains several measures (\"subdatasets\") in\naddition to NDVI, and we've only shown the first. We can use the `subds` \nargument to select\na particular subdataset from the HDF5 file. ([Later](#access-metadata), we'll \nshow how you can use the metadata to find the correct subdataset name.)\n\nMaking these adjustments, we get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_cmg <- rast(\n  files, \n  subds = \"//HDFEOS/GRIDS/VIIRS_Grid_monthly_VI_CMG/Data_Fields/CMG_0.05_Deg_monthly_NDVI\",\n  noflip = TRUE\n)\n\n# Don't forget to attach geographic info as we've re-loaded the file!\next(viirs_cmg) <- c(-180, 180, -90, 90)\ncrs(viirs_cmg) <- \"epsg:4326\"\n```\n:::\n\n\n\nWe now have a georeferenced NDVI raster dataset for 3 months:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_cmg\n#> class       : SpatRaster \n#> dimensions  : 3600, 7200, 3  (nrow, ncol, nlyr)\n#> resolution  : 0.05, 0.05  (x, y)\n#> extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> sources     : VNP13C2.A2014001.002.2024060013808.h5://CMG_0.05_Deg_monthly_NDVI  \n#>               VNP13C2.A2014032.002.2024060030203.h5://CMG_0.05_Deg_monthly_NDVI  \n#>               VNP13C2.A2014060.002.2024060044137.h5://CMG_0.05_Deg_monthly_NDVI  \n#> varnames    : CMG_0 \n#>               CMG_0 \n#>               CMG_0 \n#> names       : CMG_0.05_D~nthly_NDVI, CMG_0.05_D~nthly_NDVI, CMG_0.05_D~nthly_NDVI\n```\n:::\n\n\n\nA quick map of our data shows that it's now oriented correctly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(viirs_cmg[[1]])\n```\n:::\n\n::: {.cell .column-page}\n::: {.cell-output-display}\n![](images/global-map-2.png){width=100%}\n:::\n:::\n\n\n\nHowever, our NDVI units still appear to be off—we'd expect them to range \nfrom -1 to 1, but here we see they appear to be scaled. The \n[VIIRS documentation](https://viirsland.gsfc.nasa.gov/PDF/SNPP_VIIRS_VI_UserGuide_09-26-2017_KDidan.pdf) \nindicates that the values have been scaled by 10000 and that the valid range \nof data is from -10000 to 10000.\n\nWe'll rescale our data with simple division:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rescale data\nviirs_cmg <- viirs_cmg / 10000\n```\n:::\n\n\n\nThen, we'll use `classify()` to convert all raster values below -1 to missing\nvalues. `classify()` expects a matrix that contains an input range (in this\ncase, `-Inf` to `-1`) and an output value that should be used as a replacement\nfor values in that range (in this case, `NA`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reclassify out-of-range data to NA\nm <- matrix(c(-Inf, -1, NA), nrow = 1)\nviirs_cmg <- classify(viirs_cmg, m)\n```\n:::\n\n\n\nThis looks much better:\n\n<!-- ```{r} -->\n<!-- #| cache: true -->\n<!-- #| echo: false -->\n<!-- #| code-fold: true -->\n<!-- #| code-summary: \"Show plot code\" -->\n<!-- #| column: page -->\n<!-- #| include: false -->\n<!-- ndvi_pal <- list( -->\n<!--   pal = c( -->\n<!--     \"#fdfbdc\", -->\n<!--     \"#f1f4b7\", -->\n<!--     \"#d3ef9f\", -->\n<!--     \"#a5da8d\", -->\n<!--     \"#6cc275\", -->\n<!--     \"#51a55b\", -->\n<!--     \"#397e43\", -->\n<!--     \"#2d673a\", -->\n<!--     \"#1d472e\" -->\n<!--   ), -->\n<!--   values = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1) -->\n<!-- ) -->\n\n<!-- ggplot() + -->\n<!--   layer_spatial(viirs_cmg[[1]]) + -->\n<!--   scale_fill_gradientn( -->\n<!--     colors = ndvi_pal$pal, -->\n<!--     values = ndvi_pal$values, -->\n<!--     limits = c(0, 1), -->\n<!--     na.value = \"transparent\" -->\n<!--   ) + -->\n<!--   theme_void() + -->\n<!--   guides(fill = \"none\") -->\n<!-- ``` -->\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(viirs_cmg[[1]])\n```\n:::\n\n::: {.cell .column-page}\n::: {.cell-output-display}\n![](images/global-map-3.png){width=100%}\n:::\n:::\n\n\n\nAt this point, we could load spatial boundary files for a particular region\nto crop our data and proceed with our analysis. We've covered this kind of\nprocess [previously](../2024-08-01-ndvi-data/#crop-tiles), so we won't \ndemonstrate again here. As is often the \ncase, the bulk of the work when introducing a new data product is figuring\nout how to get it loaded and prepared correctly.\n\n# Working with other VIIRS data products\n\nSo far we've been working with global, coarse-resolution data. In our previous\n[MODIS post](../2024-08-01-ndvi-data), we instead showed how to \naccess higher-resolution data for a particular region of interest.\n\nAs a more direct analog to our previous workflow, we'll quickly demonstrate how\nthat process can be updated for use with VIIRS HDF5 files. This will\nalso give us a chance to show you how you can access HDF5 file metadata to \nhelp identify subdatasets and geographic information for a file.\n\n## HDF5 metadata\n\nIn general, the process for loading and working with higher-resolution files\nmirrors the process we demonstrated above. However, instead of downloading \nglobal data, we'll download data for a collection of\n**tiles** of data in our area of interest.\n\n::: {.callout-tip}\nWe showed you how to use Earthdata Search to download data on a tile-by-tile\nbasis in our [MODIS post](../2024-08-01-ndvi-data/#earthdata-search). The \nonly difference here is that we've downloaded\ndata for the VNP13A1 product, not the MOD13Q1 product.\n:::\n\nThere are two key differences when working with VNP13A1 as compared to the\nglobal VNP13C2 data described above.\n\n- First, NASA uses a **sinusoidal projection** for its high resolution \nproducts, not the geographic coordinates used for the global CMG product.\n- Second, because we will be stitching together multiple tiles of data, each\nwill have a different geographic extent.\n\nTo deal with these additional complexities, we'll need to access the file\nmetadata directly to attempt to identify the correct CRS and extent information.\n\n### Bioconductor and the rhdf5 package\n\n\n\n::: {.cell}\n\n:::\n\n\n\nFirst, we'll load a collection of 8 HDF files that cover 2 timestamps for the \nsame 4 tiles that we used in our MODIS post. We've placed them in a \n`data/VNP13A1` directory.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- list.files(\"data/VNP13A1\", full.names = TRUE)\n```\n:::\n\n\n\nUnfortunately, terra isn't designed to provide flexible access to metadata\nfor HDF5 files. However, there is another R package that can help, appropriately\nnamed `{rhdf5}`.\n\nrhdf5 is a package from [Bioconductor](https://www.bioconductor.org/), an \nopen-source software project focused on building bioinformatics tools. You're\nprobably familiar with installing packages from \n[CRAN](https://cran.r-project.org/), which is the default behavior when using\n`install.packages()`, but Bioconductor packages are not stored on CRAN.\n\nFortunately, Bioconductor maintains the `{BiocManager}` package to help install\nBioconductor packages. If you've never worked with a Bioconductor package before,\nyou can install the manager with\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"BiocManager\")\n```\n:::\n\n\n\nThen, you can use it to install rhdf5:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBiocManager::install(\"rhdf5\")\n```\n:::\n\n\n\nNote that you'll only need to do this once, unless you later need to update\nthe `BiocManager` or `rhdf5` packages. \n\n### Accessing metadata {#access-metadata}\n\nFirst, we'll load the `{rhdf5}` package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rhdf5)\n```\n:::\n\n\n\nWe can view the available data and metadata fields in an HDF5 file with\n`h5ls()`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds <- h5ls(files[1])\n```\n:::\n\n\n\nHDF5 files are organized into **groups**. Groups refer to an abstract collection\nof objects, like datasets or metadata objects. Each data object has a **name**.\nYou can think of each group as a directory and the objects inside\nas different files within that directory.\n\nFor instance, if we view this file's groups, we notice that there are several\nentries in the `Data Fields` group, among others:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds$group\n#>  [1] \"/\"                                                 \n#>  [2] \"/HDFEOS\"                                           \n#>  [3] \"/HDFEOS/ADDITIONAL\"                                \n#>  [4] \"/HDFEOS\"                                           \n#>  [5] \"/HDFEOS/GRIDS\"                                     \n#>  [6] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m\"            \n#>  [7] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#>  [8] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#>  [9] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [10] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [11] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [12] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [13] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [14] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [15] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [16] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [17] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [18] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [19] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [20] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [21] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [22] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [23] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"\n#> [24] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m\"            \n#> [25] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m\"            \n#> [26] \"/\"                                                 \n#> [27] \"/HDFEOS INFORMATION\"                               \n#> [28] \"/HDFEOS INFORMATION\"                               \n#> [29] \"/HDFEOS INFORMATION\"\n```\n:::\n\n\n\nIf we look at the specific objects within these groups, we see that each\nof these data fields is a different metric (e.g. \nEVI [Enhanced Vegetation Index], NDVI, etc.):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(ds$group, ds$name, sep = \"/\")\n#>  [1] \"//HDFEOS\"                                                                                  \n#>  [2] \"/HDFEOS/ADDITIONAL\"                                                                        \n#>  [3] \"/HDFEOS/ADDITIONAL/FILE_ATTRIBUTES\"                                                        \n#>  [4] \"/HDFEOS/GRIDS\"                                                                             \n#>  [5] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m\"                                                    \n#>  [6] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields\"                                        \n#>  [7] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days EVI\"                      \n#>  [8] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days EVI2\"                     \n#>  [9] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days NDVI\"                     \n#> [10] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days NIR reflectance\"          \n#> [11] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days SWIR1 reflectance\"        \n#> [12] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days SWIR2 reflectance\"        \n#> [13] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days SWIR3 reflectance\"        \n#> [14] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days VI Quality\"               \n#> [15] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days blue reflectance\"         \n#> [16] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days composite day of the year\"\n#> [17] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days green reflectance\"        \n#> [18] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days pixel reliability\"        \n#> [19] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days red reflectance\"          \n#> [20] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days relative azimuth angle\"   \n#> [21] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days sun zenith angle\"         \n#> [22] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/500 m 16 days view zenith angle\"        \n#> [23] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data Fields/Projection\"                             \n#> [24] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/XDim\"                                               \n#> [25] \"/HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/YDim\"                                               \n#> [26] \"//HDFEOS INFORMATION\"                                                                      \n#> [27] \"/HDFEOS INFORMATION/ArchiveMetadata.0\"                                                     \n#> [28] \"/HDFEOS INFORMATION/CoreMetadata.0\"                                                        \n#> [29] \"/HDFEOS INFORMATION/StructMetadata.0\"\n```\n:::\n\n\n\nOf particular interest is the `\"500 m 16 days NDVI\"` data field, which \ncontains the NDVI data we'll eventually want to load.\n\nAlso of note is the `\"/HDFEOS INFORMATION/StructMetadata.0\"` object. By\nconvention, this is where NASA stores some of the key geographic metadata\nfor the file.\n\nWe can read the HDF5 metadata using `h5read()`. The `name` argument should\nbe set to one of the `group` and `name` values from the `h5ls()` output above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata <- h5read(files[1], name = \"//HDFEOS INFORMATION/StructMetadata.0\")\n```\n:::\n\n\n\nYou can use `cat()` to display the metadata text in the R console, making it a\nbit easier to read.\n\n\n\n::: {.cell out.lines='15'}\n\n```{.r .cell-code}\ncat(metadata)\n#> GROUP=SwathStructure\n#> END_GROUP=SwathStructure\n#> GROUP=GridStructure\n#> \tGROUP=GRID_1\n#> \t\tGridName=\"VIIRS_Grid_16Day_VI_500m\"\n#> \t\tXDim=2400\n#> \t\tYDim=2400\n#> \t\tUpperLeftPointMtrs=(3335851.559000,1111950.519667)\n#> \t\tLowerRightMtrs=(4447802.078667,0.000000)\n#> \t\tProjection=HE5_GCTP_SNSOID\n#> \t\tProjParams=(6371007.181000,0,0,0,0,0,0,0,0,0,0,0,0)\n#> \t\tSphereCode=-1\n#> \t\tGROUP=Dimension\n#> \t\t\tOBJECT=Dimension_1\n#> \t\t\t\tDimensionName=\"dimofone\"\n....\n```\n:::\n\n\n\n#### Projection metadata\n\nNotice the `Projection` and `ProjParams` rows in the output above. These show \ndetails about the projection and projection parameters for our data. On their \nown, they're hard  to interpret, but a quick look at the VIIRS documentation \nreveals that this is the NASA code for the sinusoidal projection.\n\nWe can use a [PROJ-string](https://proj.org/en/stable/usage/quickstart.html) \nto represent this projection. This will allow us to\nassign the appropriate projection when we later load our data.\n\n::: {.aside}\n[PROJ](https://proj.org/en/stable/about.html) is a set of software tools \nthat support transformations between coordinate reference systems. PROJ-strings\nare one way to represent the parameters of a specific projection in a way that\nPROJ can interpret.\n:::\n\nFor the sinusoidal projection, we can use the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsinu_proj <- \"+proj=sinu +lon_0=0 +x_0=0 +y_0=0 +R=6371007.181 +units=m +no_defs\"\n```\n:::\n\n\n\n::: {.callout-note}\nNote that this is the projection that NASA uses for all its tiled VIIRS\n(and MODIS) products. Even if you're working with a different tile, you can\nuse the same projection string to set the CRS of the raster you're working with.\n:::\n\n#### Extent metadata\n\nThe `UpperLeftPointMtrs` and `LowerRightMtrs` metadata rows show the \nlocations of the upper left and lower right points of the raster grid in the \nsinusoidal projection.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n....\n#>      UpperLeftPointMtrs=(3335851.559000,1111950.519667)\n#>      LowerRightMtrs=(4447802.078667,0.000000)\n....\n```\n:::\n\n\n\nFrom these, we can determine the extent of our raster \ngrid. To simplify things, we'll just hard-code these points in this demo:\n\n::: {.aside}\nYou could also use \n[regular expressions](https://stringr.tidyverse.org/articles/regular-expressions.html) \nto extract the numeric values\nthemselves. We use this approach in our iterative workflow \n[later](#using-string-matching-to-identify-tile-extent-coordinates) in the post.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nul <- c(3335851.559, 1111950.519667)\nlr <- c(4447802.078667, 0)\n```\n:::\n\n\n\n`{terra}` expects the extent to be in (xmin, xmax, ymin, ymax) order. In our\ncase, this corresponds to (upper-left x-coordinate, lower-right x-coordinate, lower-right y-coordinate, upper-left y-coordinate).\n\nWe'll use terra's `ext()` to create a `SpatExtent` object containing the extent:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using (xmin, xmax, ymin, ymax) order\nextent <- ext(ul[1], lr[1], lr[2], ul[2])\n\nextent\n#> SpatExtent : 3335851.559, 4447802.078667, 0, 1111950.519667 (xmin, xmax, ymin, ymax)\n```\n:::\n\n\n\n::: {.callout-note}\nNote that when working with multiple tiles, you'll need to get the extent\ninformation *individually* for each tile, as each tile contains data for a\ndifferent geographic area.\n\nWe'll show one way to deal with this [below](#viirs-iterative-workflow), \nwhere we update the iterative\nworkflow we demonstrated in our MODIS post to work with VIIRS files.\n:::\n\n### Using metadata\n\nWe can use the metadata we've explored to improve our data loading workflow\nand attach correct geographic information to the loaded data.\n\nFirst, we'll use the NDVI subdataset name we identified above to load\njust the NDVI raster, ignoring other bands:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_ndvi <- rast(\n  files[1], \n  subds = \"//HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data_Fields/500_m_16_days_NDVI\",\n  noflip = TRUE\n)\n```\n:::\n\n\n\nNow, we can assign our sinusoidal projection to our data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(viirs_ndvi) <- sinu_proj\n```\n:::\n\n\n\nAs well as the extent we created above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\next(viirs_ndvi) <- extent\n```\n:::\n\n\n\nFinally, we'll make the scale adjustments that we introduced when working with\nthe global CMG data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rescale NDVI values\nviirs_ndvi <- viirs_ndvi / 10000\n\n# Replace out-of-range values with NA\nm <- matrix(c(-Inf, -1, NA), nrow = 1)\nviirs_ndvi <- classify(viirs_ndvi, m)\n```\n:::\n\n\n\nNow we can see that our raster seems to have the appropriate CRS, extent, and \nscale!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_ndvi\n#> class       : SpatRaster \n#> dimensions  : 2400, 2400, 1  (nrow, ncol, nlyr)\n#> resolution  : 463.3127, 463.3127  (x, y)\n#> extent      : 3335852, 4447802, 0, 1111951  (xmin, xmax, ymin, ymax)\n#> coord. ref. : +proj=sinu +lon_0=0 +x_0=0 +y_0=0 +R=6371007.181 +units=m +no_defs \n#> source(s)   : memory\n#> varname     : 500_m_16_days_NDVI \n#> name        : 500_m_16_days_NDVI \n#> min value   :            -0.9688 \n#> max value   :             0.9994\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nndvi_pal <- list(\n  pal = c(\n    \"#fdfbdc\",\n    \"#f1f4b7\",\n    \"#d3ef9f\",\n    \"#a5da8d\",\n    \"#6cc275\",\n    \"#51a55b\",\n    \"#397e43\",\n    \"#2d673a\",\n    \"#1d472e\" \n  ),\n  values = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1)\n)\n\nggplot() + \n  layer_spatial(viirs_ndvi) +\n  coord_sf(datum = sf::st_crs(viirs_ndvi)) +\n  scale_fill_gradientn(\n    colors = ndvi_pal$pal,\n    values = ndvi_pal$values,\n    limits = c(0, 1),\n    na.value = \"transparent\"\n  ) +\n  labs(\n    title = \"VIIRS NDVI\", \n    subtitle = \"Tile h21v08, January 1-16, 2014\", \n    fill = \"NDVI\",\n    caption = \"Source: NASA Visible Infrared Imaging Radiometer Suite (VIIRS)\"\n  ) +\n  theme_dhs_map() +\n  theme_dhs_base()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=100%}\n:::\n:::\n\n\n\n\n\n# An iterative workflow for multiple tiles {#viirs-iterative-workflow}\n\nIn our [MODIS post](../2024-08-01-ndvi-data/#an-iterative-r-workflow), \nwe demonstrated a way to load and process multiple tiles\nof data using `{purrr}` and `{terra}`.\n\nFor the most part, this workflow can be directly applied to VIIRS files. \nThe primary difference is\nthat each of the tiles will have a different geographic extent. Our workflow\ntherefore will need to correctly identify and assign the extent on a\n**per-tile** basis.\n\nCertainly, you could reproduce the process we just introduced for a single file\nto manually update extent and projection information for multiple files. But\nif you're working with many tiles or time points, it may be worthwhile to \nautomate the data loading process.\n\nWe'll reproduce an analogous workflow to the one we introduced for MODIS tiles\nhere.\n\n::: {.callout-note}\nBecause this workflow tracks closely with the workflow we've shown \n[previously](../2024-08-01-ndvi-data/#an-iterative-r-workflow), we won't spend a\nlot of time discussing the details of our code in this section. We've included\nit primarily to serve as a reference for how the transition from MODIS to VIIRS\nmay affect the approach we've previously shown.\n\nIn many cases, global CMG data may be more appropriate, and you can\navoid needing to load data from multiple tiles.\n:::\n\n## Identify tile codes\n\nAs we demonstrated last time, we'll identify each unique tile code from our\nfile names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntile_codes <- unique(str_extract(files, \"h[0-9]{2}v[0-9]{2}\"))\n\ntile_codes\n#> [1] \"h21v08\" \"h21v09\" \"h22v08\" \"h22v09\"\n```\n:::\n\n\n\nThis allows us to group our files by tile into a list:\n\n\n\n::: {.cell scrub_data_local='true'}\n\n```{.r .cell-code}\ntiles <- map(\n  tile_codes,\n  function(code) files[str_detect(files, code)]\n)\n\ntiles\n#> [[1]]\n#> [1] \"data/VNP13A1/VNP13A1.A2014001.h21v08.002.2024059234751.h5\"\n#> [2] \"data/VNP13A1/VNP13A1.A2014017.h21v08.002.2024060002117.h5\"\n#> \n#> [[2]]\n#> [1] \"data/VNP13A1/VNP13A1.A2014001.h21v09.002.2024059234749.h5\"\n#> [2] \"data/VNP13A1/VNP13A1.A2014017.h21v09.002.2024060002133.h5\"\n#> \n#> [[3]]\n#> [1] \"data/VNP13A1/VNP13A1.A2014001.h22v08.002.2024059234752.h5\"\n#> [2] \"data/VNP13A1/VNP13A1.A2014017.h22v08.002.2024060002157.h5\"\n#> \n#> [[4]]\n#> [1] \"data/VNP13A1/VNP13A1.A2014001.h22v09.002.2024059234755.h5\"\n#> [2] \"data/VNP13A1/VNP13A1.A2014017.h22v09.002.2024060002123.h5\"\n```\n:::\n\n\n\n## Using string matching to identify tile extent coordinates\n\nNow, for each of these tiles, we can extract the metadata for the first file\nusing `h5read()`. (Recall that the two files in each group are differentiated \nby their timestamps, but share the same geographic extent.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntile_metadata <- map(\n  tiles,\n  function(t) h5read(t[1], name = \"//HDFEOS INFORMATION/StructMetadata.0\")\n)\n```\n:::\n\n\n\nThe metadata are in string format. To extract the upper left and lower right\ncoordinates, we'll need to use regular expressions to pull out the\ntext coordinates and convert to numeric values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nul <- map(\n  tile_metadata,\n  ~ str_match(.x, \"UpperLeftPointMtrs=\\\\((.*?)\\\\)\")[, 2]\n)\n\nul <- map(str_split(ul, \",\"), as.numeric)\n\nul\n#> [[1]]\n#> [1] 3335852 1111951\n#> \n#> [[2]]\n#> [1] 3335852       0\n#> \n#> [[3]]\n#> [1] 4447802 1111951\n#> \n#> [[4]]\n#> [1] 4447802       0\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlr <- map_chr(\n  tile_metadata,\n  ~ str_match(.x, \"LowerRightMtrs=\\\\((.*?)\\\\)\")[, 2]\n)\n\nlr <- map(str_split(lr, \",\"), as.numeric)\n\nlr\n#> [[1]]\n#> [1] 4447802       0\n#> \n#> [[2]]\n#> [1]  4447802 -1111951\n#> \n#> [[3]]\n#> [1] 5559753       0\n#> \n#> [[4]]\n#> [1]  5559753 -1111951\n```\n:::\n\n\n\nNow we can convert these points to extents using terra's conventions. We use\n`map2()` to iterate over both sets of points **in parallel**. That is, we'll\nuse the first point in the `ul` list along with the first point in the `lr`\nlist to construct the first extent, and so on.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntile_ext <- map2(ul, lr, function(u, l) ext(u[1], l[1], l[2], u[2]))\n\ntile_ext\n#> [[1]]\n#> SpatExtent : 3335851.559, 4447802.078667, 0, 1111950.519667 (xmin, xmax, ymin, ymax)\n#> \n#> [[2]]\n#> SpatExtent : 3335851.559, 4447802.078667, -1111950.519667, 0 (xmin, xmax, ymin, ymax)\n#> \n#> [[3]]\n#> SpatExtent : 4447802.078667, 5559752.598333, 0, 1111950.519667 (xmin, xmax, ymin, ymax)\n#> \n#> [[4]]\n#> SpatExtent : 4447802.078667, 5559752.598333, -1111950.519667, 0 (xmin, xmax, ymin, ymax)\n```\n:::\n\n\n\n## Load all tiles\n\nNow, we need to load the data for each tile, updating its CRS and extent\ninformation with the corresponding extent for that tile. Since we need to \niterate over both **tiles** and **extents**, we'll again use `map2()`. This will\nload the first tile and apply the first extent, then the second tile with the\nsecond extent, and so on.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_tiles <- map2(\n  tiles,\n  tile_ext,\n  function(tile, ext) {\n    # Load raster for the input tile. We select the NDVI subdataset\n    r <- rast(\n      tile, \n      subds = \"//HDFEOS/GRIDS/VIIRS_Grid_16Day_VI_500m/Data_Fields/500_m_16_days_NDVI\",\n      noflip = TRUE\n    )\n    \n    crs(r) <- sinu_proj # Attach sinusoidal projection defined above\n    ext(r) <- ext # Attach this tile's extent\n    \n    r # Return the updated raster for this tile\n  }\n)\n```\n:::\n\n\n\n## Mosaic georeferenced tiles\n\nAs we did in our [MODIS post](../2024-08-01-ndvi-data/#mosaic-tiles), we'll \nnow mosaic all the tiles together into a single source:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_mosaic <- reduce(viirs_tiles, mosaic)\n```\n:::\n\n\n\nAnd take care of the NDVI adjustments we described above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nviirs_mosaic <- viirs_mosaic / 10000\n\nm <- matrix(c(-Inf, -1, NA), nrow = 1)\nviirs_mosaic <- classify(viirs_mosaic, m)\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nlibrary(sf)\nlibrary(patchwork)\n\nke_borders <- ipumsr::read_ipums_sf(\"data/geo_ke1989_2014.zip\") |> \n  st_make_valid() |> # Fix minor border inconsistencies\n  st_union() |> \n  st_transform(crs(viirs_mosaic))\n\nke_viirs <- crop(viirs_mosaic, ke_borders)\nke_viirs_mask <- mask(ke_viirs, vect(ke_borders))\n\np1 <- ggplot() + \n  layer_spatial(ke_viirs_mask[[1]]) +\n  layer_spatial(st_simplify(ke_borders, dTolerance = 1000), fill = NA) +\n  coord_sf(datum = sf::st_crs(viirs_ndvi)) +\n  scale_fill_gradientn(\n    colors = ndvi_pal$pal,\n    values = ndvi_pal$values,\n    limits = c(0, 1),\n    na.value = \"transparent\"\n  ) +\n  labs(subtitle = \"January 1-16, 2014\", fill = \"NDVI\") +\n  theme_dhs_map() +\n  theme_dhs_base()\n\np2 <- ggplot() + \n  layer_spatial(ke_viirs_mask[[2]]) +\n  layer_spatial(st_simplify(ke_borders, dTolerance = 1000), fill = NA) +\n  coord_sf(datum = sf::st_crs(viirs_ndvi)) +\n  scale_fill_gradientn(\n    colors = ndvi_pal$pal,\n    values = ndvi_pal$values,\n    limits = c(0, 1),\n    na.value = \"transparent\"\n  ) +\n  labs(subtitle = \"January 17-31, 2014\", fill = \"NDVI\") +\n  theme_dhs_map() +\n  theme_dhs_base()\n\np1 + p2 +\n  plot_layout(guides = \"collect\", ncol = 2) +\n  plot_annotation(\n    title = \"NDVI: Kenya\",\n    caption = \"Source: NASA Visible Infrared Imaging Radiometer Suite (VIIRS)\"\n  ) &\n  theme(legend.position='bottom')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-50-1.png){width=100%}\n:::\n:::\n\n\n\nFortunately, you can avoid most of this processing when working with\nglobal data, as the data have a simpler CRS and are already whole.\nWhile you're likely to want to use global CMG data\nfor most purposes, it's worthwhile to be aware of some of the quirks required\nfor handling VIIRS files when working with multiple tiles. That being said,\nresist the temptation to always use high-resolution data! Always assess the\nspatial resolution of your other data sources to determine when it may be\nmore appropriate to rely on the simpler global VIIRS data.\n\n## Getting Help {.appendix}\n\nQuestions or comments? Check out the [IPUMS User\nForum](https://forum.ipums.org) or reach out to IPUMS User Support at\nipums\\@umn.edu.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}