{
  "hash": "efcafa64eeef80b08d1da9d838c46f22",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Flexible Workflows with CHIRTS Temperature Data\"\ndescription: |\n  Generalize your code to more easily aggregate time-varying environmental data\nauthor: \n  - name: \"Finn Roberts\"\n    affiliation: Senior Data Analyst, IPUMS\ndate: 04-15-2024\ncategories:\n  - CHIRTS\n  - Temperature\n  - Heat\n  - Extreme weather\n  - Time series\n  - Reproducible workflows\n  - Functional programming\n  - terra\n  - sf\n  - ggspatial\n  - R\nfig-width: 10\nfig-height: 8\nimage: index_files/figure-html/listing-img-1.png\nbibliography: references.bib\nopen-graph:\n  title: \"Reproducible Workflows with CHIRTS Temperature Data\"\n  description: |\n    Build flexibile workflows to more easily aggregate time-varying \n    environmental data\n  image: index_files/figure-html/listing-img-1.png\ntwitter-card:\n  title: \"Reproducible Workflows with CHIRTS Temperature Data\"\n  description: |\n    Build flexibile workflows to more easily aggregate time-varying \n    environmental data\n  image: index_files/figure-html/listing-img-1.png\n---\n\n::: {.cell}\n\n:::\n\n\n\nIn our [previous technical post](../2024-02-04-dhs-chirps/index.html),\nwe showed how to reduce a daily time series of environmental data for an\nentire country into a single digestible metric that can be attached to\n[DHS survey](https://www.dhsprogram.com/) data for use in an analysis.\n\nHowever, as we mentioned then, a long-run average isn't always the most\nappropriate way to aggregate raster values across time. As an example,\nimagine we were interested in the impacts of **extreme heat** on child\n**birth weight**. The proximate conditions in the several months\npreceding each child's birth are likely to be more consequential for\nthat child's health than the average conditions over many\nyears.[@Grace2021]\n\n# A new approach\n\nTo explore this idea, we could instead aggregate temperature data to the\na more fine-grained temporal level and selectively consider the\ntemperature in a specified time range before each child's birth.\n\nFortunately, DHS surveys do record some temporal information, including\nthe timing of the survey interview as well as birth dates for survey\nrespondents and children. But these details are recorded at the\n**monthly** level. To account for the uncertainty in the dates reported\nin DHS surveys, we need to aggregate our CHIRTS data to the monthly\nlevel as well.\n\nThis approach adds three key dimensions to the techniques introduced in\nour precipitation post. We need to:\n\n1.  calculate a temperature exposure metric at the monthly level\n2.  identify the relevant months of temperature data for each child\n    based on their recorded birth month\n3.  summarize each child's temperature exposure using their individual\n    monthly time series of temperature data\n\nThis post focuses on the first item; our next post in this series will\nconsider the other two. First, we'll show how to obtain the necessary\ndata for this demonstration, which come from [IPUMS\nDHS](https://www.idhsdata.org/idhs/) and the [Climate Hazards\nCenter](https://chc.ucsb.edu/) (CHC). Then, we'll build on some of the\ntools and techniques presented in our [first technical\npost](../2024-02-04-dhs-chirps/index.html) to demonstrate several ways\nto operationalize and calculate temperature exposure at the monthly\nlevel.\n\nBefore we get started, we'll load the main packages that we'll use in\nthis post:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ipumsr)\nlibrary(terra)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(ggspatial)\n```\n:::\n\n\n\n# Data preparation\n\n## DHS boundaries\n\nFor this series, we'll use the 2012 DHS sample for Mali. We won't be\nworking with the survey data until our next post, but we will be using\nthe integrated administrative boundary files from IPUMS in our maps.\n\nYou can download the boundary data directly from IPUMS DHS by clicking\nthe **shapefile** link under the Mali section of [this\ntable](https://www.idhsdata.org/idhs/gis.shtml). We’ve placed this\nshapefile in the `data/gps` directory within our project.\n\n[Previously](../2024-02-04-dhs-chirps/#loading-cluster-coordinates), we\nunzipped the shapefile and loaded it with `st_read()` from the sf\npackage. However, since IPUMS often distributes shapefiles in zip\narchives, ipumsr provides `read_ipums_sf()` as a way to read a shapefile\ndirectly without manually extracting the compressed files. We'll use\nthis convenience to load our boundary data into an `sf` object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_borders <- read_ipums_sf(\"data/gps/geo_ml1995_2018.zip\")\n\nml_borders\n#> Simple feature collection with 8 features and 3 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -12.23888 ymin: 10.14781 xmax: 4.267383 ymax: 25.00108\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 8 × 4\n#>   CNTRY_NAME ADMIN_NAME    DHSCODE                                      geometry\n#>   <chr>      <chr>           <int>                                 <POLYGON [°]>\n#> 1 Mali       Kayes               1 ((-9.330095 15.50158, -9.320187 15.50138, -9…\n#> 2 Mali       Ségou               4 ((-3.962041 13.50099, -3.963767 13.50299, -3…\n#> 3 Mali       Mopti               5 ((-0.7440053 15.06439, -0.9481987 14.88898, …\n#> 4 Mali       Tombouctou          6 ((-0.005279168 21.87488, -0.006277 21.87317,…\n#> 5 Mali       Bamako              9 ((-7.932848 12.68226, -7.932015 12.68209, -7…\n#> 6 Mali       Sikasso             3 ((-4.472905 12.71992, -4.472977 12.71908, -4…\n#> 7 Mali       Koulikoro           2 ((-9.076561 15.50138, -9.000042 15.50046, -8…\n#> 8 Mali       Gao and Kidal       7 ((-0.4509285 15.0843, -0.450753 15.0864, -0.…\n```\n:::\n\n\n\nOur boundary file includes borders for individual administrative units\nwithin Mali. However, it's often useful to have a single external border\nfor spatial operations and mapping.\n\nTo combine internal borders, we can use `st_union()` from `{sf}`.\nHowever, in this case, we first need to simplify our file so that\n`st_union()` works properly.\n\n::: callout-tip\nFor some spatial files, small misalignments may cause problems for\ncertain spatial operations. Often, you'll notice these issues in your\nmaps if errant lines or points appear in unexpected places. You can\ncheck whether a file is topologically valid with `st_is_valid()`.\n:::\n\nWe use `st_make_valid()` to correct some of these issues. Then, we can\ncombine our internal geometries with `st_union()` and simplify our\nexternal border slightly.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Validate internal borders\nml_borders_neat <- st_make_valid(ml_borders)\n\n# Collapse internal borders to get single country border\nml_borders_out <- ml_borders_neat |> \n  st_union() |> \n  st_simplify(dTolerance = 1000) |> \n  st_as_sf()\n```\n:::\n\n\n\nNow, we have both detailed internal borders as well as a single country\nborder.\n\n## CHIRTS\n\nFor our temperature data, we'll use the [Climate Hazards Center Infrared\nTemperature with Stations](https://www.chc.ucsb.edu/data/chirtsdaily)\n(CHIRTS) dataset.[@Funk2019] CHIRTS provides daily estimates for several\ntemperature metrics at a 0.05° (\\~5 kilometer) raster resolution. CHIRTS\nprovides estimates of the following measures:\n\n-   Daily maximum air temperature (2 meters above ground)\n-   Daily minimum air temperature (2 meters above ground)\n-   Daily average relative humidity\n-   Daily average heat index\n\nThe most appropriate metric will depend on the nature of your research.\nFor instance, relevant temperature metrics for studying the effects of\nheat on the human body are likely different from those used for studying\nagricultural productivity.\n\nFor health research, it's also worth considering the specifics of the\npopulation of interest, as they may employ adaptive strategies or be at\nincreased risk of heat exposure due to common pre-existing conditions or\nlifestyle features.[@Vanos2020]\n\nSince this post focuses specifically on R techniques (and not on\nmethodological considerations), we'll keep it simple and use **daily\nmaximum air temperature**.\n\nThere are two ways to go about obtaining the CHIRTS data: either via\nmanual download or via the `{chirps}` R package.\n\n### Manual download\n\nCHIRTS data for Africa can be [downloaded\ndirectly](http://data.chc.ucsb.edu/products/CHIRTSdaily/v1.0/africa_netcdf_p05/)\nfrom the Climate Hazards Center.\n\nData are distributed as\n[NetCDF](https://www.unidata.ucar.edu/software/netcdf/) files, a common\nformat for distributing scientific raster data structures. NetCDF files\ncontain metadata about the file contents (for instance, about the\ntemporal or spatial dimensions of the data), which will be useful later\nwhen we aggregate data to the monthly level.\n\nYou'll notice that the files—each of which contains a full year's worth\nof data for the entire continent of Africa—contain 3.3 *Giga*bytes of\ndata apiece. For this demonstration, we'll therefore only download a\nsingle year of data.\n\n::: callout-note\n## Climatological Normals\n\nWhen dealing with environmental data, it's often necessary to have a\nlong time series of data to establish a stable *climatological normal*,\nor baseline, to which to compare current observations. 30-year normals\nare commonly used, but their use has recently been questioned due to the\nacceleration of extreme weather frequency.[@Livezey2007]\n\nBecause of the space and time required to obtain data to calculate\nnormals at a high resolution, we won't be creating normals from CHIRTS\nin this post, but you may see them in the literature.\n:::\n\nWe're working with the 2012 Mali sample from IPUMS DHS for this example,\nso we'll download the `Tmax.2012.nc` file from the [CHC\nlisting](http://data.chc.ucsb.edu/products/CHIRTSdaily/v1.0/africa_netcdf_p05/).\nWe've placed this file in the `data` directory.\n\nFortunately, we don't need to learn any new tools to handle this file,\nas support for NetCDF is already built into `{terra}`. We can easily\nload the raster with `rast()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_chirts <- rast(\"data/Tmax.2012.nc\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nIn this post we'll be particularly interested in the temporal dimension\nof our raster data. Typically, a raster stack will represent time in\nlayers, where each layer represents the recorded values at a particular\npoint in time. terra's `SpatRaster` objects have a built-in\nrepresentation of time, which can be accessed with the `time()`\nfunction:\n\n\n\n::: {.cell out.lines='3'}\n\n```{.r .cell-code}\ntime(ml_chirts)\n#>   [1] \"2012-01-01\" \"2012-01-02\" \"2012-01-03\" \"2012-01-04\" \"2012-01-05\"\n#>   [6] \"2012-01-06\" \"2012-01-07\" \"2012-01-08\" \"2012-01-09\" \"2012-01-10\"\n#>  [11] \"2012-01-11\" \"2012-01-12\" \"2012-01-13\" \"2012-01-14\" \"2012-01-15\"\n....\n```\n:::\n\n\n\nWe can see that the temporal information contained in the NetCDF file\nwas automatically included when we loaded this raster into R. Each of\nthese dates correspond to a layer in the `SpatRaster`. This temporal\nrepresentation will become useful when we aggregate temperature to the\nmonthly level.\n\n#### Crop CHIRTS raster\n\nDownloading data from the CHC provides a raster for the entire African\ncontinent. We can greatly speed up our future processing by cropping\nthis raster to our area of interest using the Mali borders that we\nloaded above.\n\nFirst, we'll add a 10 kilometer buffer around the country border so that\nwe retain the CHIRTS data just outside of the country as well. That way,\nif any DHS clusters fall in the border regions of the country, we will\nstill be able to calculate temperature metrics in their general\nvicinity.\n\nWe've covered buffering [in the\npast](../2024-02-04-dhs-chirps/#cluster-buffers) if you need to refresh\nyour memory on this process.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transform to UTM 29N coordinates, buffer, and convert back to WGS84\nml_borders_buffer <- ml_borders_out |> \n  st_transform(crs = 32629) |> \n  st_buffer(dist = 10000) |>\n  st_transform(crs = 4326)\n```\n:::\n\n\n\nFinally, we can crop the CHIRTS raster to our buffered border region\nwith terra's `crop()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_chirts <- crop(ml_chirts, ml_borders_buffer, snap = \"out\")\n```\n:::\n\n\n\n### Access via the chirps package\n\nYou may recall from our [previous technical\npost](../2024-02-04-dhs-chirps/#option-2-the-chirps-package) that CHC\ndata can be obtained via the `{chirps}` package in R. This package\nprovides access to CHIRTS data as well.\n\nYou can obtain CHIRTS from the chirps package by providing a spatial\nboundary representing the area of interest for which the CHIRTS raster\ndata should be obtained. You'll also need to specify a temporal range\nand temperature variable.\n\nIn this case, we'll use the buffered administrative borders for Mali\nthat we downloaded earlier, specify the 2012 time range, and select the\n`\"Tmax\"` variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_chirts2 <- chirps::get_chirts(\n  vect(ml_borders_buffer), \n  dates = c(\"2012-01-01\", \"2012-12-31\"),\n  var = \"Tmax\"\n)\n```\n:::\n\n\n\n::: column-margin\nWe convert our administrative borders to a terra `SpatVector` object\nwith `vect()` because this is the spatial structure expected by\n`get_chirts()`.\n:::\n\nIn contrast to the NetCDF files provided when downloading CHIRTS data\ndirectly, obtaining data via the chirps package does not provide any\ntemporal metadata:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell out.lines='3'}\n\n```{.r .cell-code}\ntime(ml_chirts2)\n#>   [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n#>  [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n#>  [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n....\n```\n:::\n\n\n\nSince we know that we have a full year of data, we can construct the\ntemporal metadata manually. We'll use the `{lubridate}` package to make\nthis a little easier:\n\n\n\n::: {.cell out.lines='3'}\n\n```{.r .cell-code}\n# Convert strings to Date objects specifying year-month-day (ymd) format:\nstart <- lubridate::ymd(\"2012-01-01\")\nend <- lubridate::ymd(\"2012-12-31\")\n\n# Set time as a daily sequence of dates for all of 2012\ntime(ml_chirts2) <- seq(start, end, by = \"days\")\n\ntime(ml_chirts2)\n#>   [1] \"2012-01-01\" \"2012-01-02\" \"2012-01-03\" \"2012-01-04\" \"2012-01-05\"\n#>   [6] \"2012-01-06\" \"2012-01-07\" \"2012-01-08\" \"2012-01-09\" \"2012-01-10\"\n#>  [11] \"2012-01-11\" \"2012-01-12\" \"2012-01-13\" \"2012-01-14\" \"2012-01-15\"\n....\n```\n:::\n\n\n\n::: callout-caution\nManually attaching time units works in this case because we know the\nCHIRTS data have no gaps. However, there's no built-in check to ensure\nthat you're attaching the correct date to each layer of the raster\nstack, so you'll want to be sure you know what time units are truly\nrepresented by each layer before assigning them manually.\n:::\n\nAt this point, we should have a daily raster for the region around Mali.\nWe can take a peek by mapping the temperature distribution on a single\nday of our CHIRTS time series:\n\n::: column-margin\nWe're not going to explicitly demonstrate how we produce our maps in\nthis post since some are fairly complicated to set up. If you're\ncurious, you can peek at the collapsed code blocks to see how each of\nour maps are produced.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot functions\"}\n# Add map scale bar and update guides\ntheme_dhs_map <- function(show_scale = TRUE, continuous = TRUE) {\n  if (show_scale) {\n    scale <- annotation_scale(\n      aes(style = \"ticks\", location = \"br\"), \n      text_col = \"#999999\",\n      line_col = \"#999999\",\n      height = unit(0.2, \"cm\")\n    )\n  } else {\n    scale <- NULL\n  }\n  \n  if (continuous) {\n    guide <- guides(\n      fill = guide_colorbar(draw.llim = FALSE, draw.ulim = FALSE)\n    )\n  } else {\n    guide <- guides(\n      fill = guide_colorsteps(draw.llim = FALSE, draw.ulim = FALSE)\n    )\n  }\n  \n  list(scale, guide)\n}\n\n# Define custom palette functions so we can easily reproduce\n# color schemes across our maps in this post\nchirts_palettes <- function() {\n  list(\n    main = c(\"#bad3e8\", \"#ffd3a3\", \"#da5831\", \"#872e38\"),\n    diff = c(\"#5B3794\", \"#8F4D9F\", \"#B76AA8\", \"#D78CB1\", \"#F1B1BE\", \"#F8DCD9\")\n  )\n}\n\n# Continuous fill scale for a selected palette\nscale_chirts_c <- function(pal = \"main\", ...) {\n  pal <- chirts_palettes()[[pal]]\n  colorRampPalette(pal, ...)\n}\n\n# ggplot2 layer for continuous scale for selected palette\nscale_fill_chirts_c <- function(pal = \"main\", na.value = NA, ...) {\n  pal <- scale_chirts_c(pal)\n  ggplot2::scale_fill_gradientn(colors = pal(256), na.value = na.value, ...)\n}\n\n# ggplot2 layer for binned scale for selected palette\nscale_fill_chirts_b <- function(pal = \"main\", na.value = NA, ...) {\n  pal <- scale_chirts_c(pal)\n  ggplot2::scale_fill_stepsn(colors = pal(256), na.value = na.value, ...)\n}\n```\n:::\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Split raster into two at the country border to allow for differential \n# highlighting\nr_in <- mask(ml_chirts[[1]], ml_borders_out, inverse = FALSE)\nr_out <- mask(ml_chirts[[1]], ml_borders_out, inverse = TRUE)\n\n# Plot\nggplot() +\n  layer_spatial(r_in, alpha = 0.9, na.rm = TRUE) +\n  layer_spatial(r_out, alpha = 0.3, na.rm = TRUE) +\n  layer_spatial(ml_borders_neat, fill = NA, color = \"#eeeeee\") +\n  layer_spatial(ml_borders_out, fill = NA, color = \"#7f7f7f\", linewidth = 0.5) +\n  labs(\n    title = \"Daily Maximum Temperature: Mali\",\n    subtitle = \"January 1, 2012\",\n    fill = \"Temperature (°C)\",\n    caption = \"Source: Climate Hazards Center Infrared Temperature with Stations\"\n  ) +\n  scale_fill_chirts_c(limits = c(18, 50)) +\n  theme_dhs_map()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n# Calculating monthly temperature metrics\n\nAs we mentioned in the introduction, our ultimate goal is to identify\nthe temperature trends prior to each birth in our DHS sample. However,\nDHS survey data record temporal information about interviews and births\nat the **monthly** level. Thus, the most accurate we can be is to\nidentify temperature running up to the **month** immediately prior to a\nchild's birth.\n\nWe therefore need to aggregate our daily CHIRTS data to the monthly\nlevel. In the rest of the post, we'll demonstrate how to calculate\nseveral possible monthly metrics in R. Then, in a future post, we'll\ndemonstrate how to attach the monthly CHIRTS data to each record in our\nDHS sample.\n\n::: callout-note\n## Defining Heat Exposure\n\nA vast array of methods to identify extreme temperature and heatwave\nexposure exist in the literature, and we can't demonstrate the\nprocessing required for each and every one. However, the approaches we\ndemonstrate should give you a sense of the tools and techniques\navailable for you when working with temperature data in your own\nresearch.\n:::\n\n## 1. Average monthly temperature\n\nFor our first metric, we'll take a simple approach and calculate an\naverage monthly temperature.\n\n[Previously](../2024-02-04-dhs-chirps/#summarize-precipitation-values),\nwe introduced terra's `mean()` method, which allows you to calculate a\nsingle mean across all layers of a `SpatRaster` object. In this case, we\nalso want to calculate a mean, but we need to adapt our approach so we\ncan do so for each month independently.\n\nEnter terra's `tapp()` function. `tapp()` allows you to apply a function\nto **groups of raster layers**. You can indicate which layers should be\ngrouped together with the `index` argument. For instance, to\nindependently calculate the mean of the first three layers and the\nsecond three layers, we could use the following `index`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntapp(\n  ml_chirts[[1:6]], # Select the first 6 layers to demo\n  fun = mean, \n  index = c(1, 1, 1, 2, 2, 2)\n)\n#> class       : SpatRaster \n#> dimensions  : 301, 335, 2  (nrow, ncol, nlyr)\n#> resolution  : 0.05, 0.05  (x, y)\n#> extent      : -12.35, 4.399999, 10.05, 25.1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source(s)   : memory\n#> names       :       X1,       X2 \n#> min values  : 20.32146, 21.20080 \n#> max values  : 35.77333, 35.86034\n```\n:::\n\n\n\nNotice that this produces an output `SpatRaster` with 2 layers: the\nfirst represents the mean of the first 3 layers in the input, and the\nsecond represents the mean of the next 3 layers.\n\nHowever, manually identifying the index layers for each month of the\nyear would be tedious and error-prone. Not only would we have to type\nout code to handle 366 days of data, but we would also have to contend\nwith the fact that months vary in length. And depending on your time\nframe and region of interest, you may also need to account for leap\nyears or entirely different calendars!\n\nFortunately, terra provides us with an easier way. Because we have a\n`time` component to our data, we can use the temporal metadata already\nattached to our raster as the index. For instance, to aggregate by\nmonth, simply use `index = \"months\"`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_chirts_mean <- tapp(ml_chirts, fun = mean, index = \"months\")\n\nml_chirts_mean\n#> class       : SpatRaster \n#> dimensions  : 301, 335, 12  (nrow, ncol, nlyr)\n#> resolution  : 0.05, 0.05  (x, y)\n#> extent      : -12.35, 4.399999, 10.05, 25.1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source(s)   : memory\n#> names       :      m_1,      m_2,      m_3,      m_4,      m_5,      m_6, ... \n#> min values  : 20.13009, 21.27224, 27.66812, 29.93578, 29.76501, 26.91157, ... \n#> max values  : 35.44701, 38.60472, 40.72202, 42.85499, 44.10707, 47.46994, ... \n#> time (mnts) : Jan to Dec\n```\n:::\n\n\n\nAs expected, we now have 12 layers in our output `SpatRaster` (see the\n`dimensions` component of the output above). Each layer contains the\naverage daily maximum temperature (in degrees Celsius) for the given\nmonth, as shown below.\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nlibrary(patchwork)\n\n# Helper to split raster layers into a list for small-multiple panel mapping\nsplit_raster <- function(r) {\n  purrr::map(seq_len(nlyr(r)), function(i) r[[i]])\n}\n\n# Function to build individual panels for a small-multiple map using \n# continuous color scheme\nchirts_panel_continuous <- function(x, \n                                    panel_title = \"\",\n                                    show_scale = TRUE,\n                                    ...) {\n  r_in <- mask(x, ml_borders_out, inverse = FALSE)\n  \n  ggplot() + \n    layer_spatial(r_in, alpha = 0.9, na.rm = TRUE) +\n    layer_spatial(ml_borders_neat, fill = NA, color = \"#eeeeee\") +\n    layer_spatial(ml_borders_out, fill = NA, color = \"#7f7f7f\") +\n    labs(subtitle = panel_title, fill = \"Temperature (°C)\") +\n    scale_fill_chirts_c(...) +\n    theme_dhs_map(show_scale = show_scale) +\n    theme(\n      axis.text.x = element_blank(), \n      axis.text.y = element_blank(),\n      plot.subtitle = element_text(hjust = 0.5, size = 12),\n      panel.grid = element_blank()\n    )\n}\n\n# Split raster by layer\nr <- split_raster(ml_chirts_mean)\n\n# Show scale only on final panel\nshow_scale <- c(rep(FALSE, length(r) - 1), TRUE)\n\n# Panel labels\nmonths <- c(\"January\", \"February\", \"March\", \"April\", \n            \"May\", \"June\", \"July\", \"August\",\n            \"September\", \"October\", \"November\", \"December\")\n\n# Create map panels\npanels <- purrr::pmap(\n  list(r, months, show_scale),\n  function(x, y, z) chirts_panel_continuous(x, y, z, limits = c(18, 50))\n)\n\n# Plot\nwrap_plots(panels) +\n  plot_layout(guides = \"collect\", ncol = 4) +\n  plot_annotation(\n    title = \"Average Monthly Temperature: Mali 2012\",\n    caption = \"Source: Climate Hazards Center Infrared Temperature with Stations\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nNote that the CHC does provide a [CHIRTS\nproduct](https://chc.ucsb.edu/data/chirtsmonthly) that has been\npre-aggregated to the monthly level. For projects relying on average\nmonthly temperature, this is likely a better option than manually\naggregating more fine-grained CHIRTS data.\n\nHowever, the advantage to working with *daily* CHIRTS data is that we\nhave the flexibility to calculate our own custom monthly temperature\nmetrics that aren't necessarily provided out-of-the-box. We'll\ndemonstrate one in the next section.\n\n## 2. Days above a temperature threshold {#days-above}\n\nAverage temperature may be a straightforward monthly temperature metric,\nbut it doesn't do a very good job of capturing acute temperature\n**anomalies**. When it comes to human health, evidence suggests that\ntemperatures above certain thresholds are associated with physiological\nimpairments, though the precise threshold depends on several\nfactors.[@Vanos2020] Regardless, these extreme events may be masked when\nwe average across an entire month.\n\nTo explore this possibility, we'll calculate the proportion of days in\neach month that exceed a certain raw temperature threshold. We'll use\n35°C as our threshold, which represents a value near the upper end of\nMali's temperature distribution[@Grace2021] and is similar to other\ncommonly used (though occasionally questionable) thresholds.[@Vanos2020]\n\n::: column-margin\nTypically, you would want a more thorough justification of your\nthreshold temperature. This post is not intended to represent a real\nanalysis, so we select 35°C for the purposes of demonstration.\n:::\n\n### Logical raster operations\n\nWe can exploit the fact that terra supports logical operations on\n`SpatRaster` objects to help us calculate this metric. For instance, we\ncan compare the entire raster to a set value with the familiar `>`\noperator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_bin <- ml_chirts > 35\n```\n:::\n\n\n\nThis produces a binary raster, where each pixel in each layer receives a\nlogical value based on whether it is above or below 35 degrees Celsius\n(note that the `min values` and `max values` for each layer are now\n`TRUE` or `FALSE`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_bin\n#> class       : SpatRaster \n#> dimensions  : 301, 335, 366  (nrow, ncol, nlyr)\n#> resolution  : 0.05, 0.05  (x, y)\n#> extent      : -12.35, 4.399999, 10.05, 25.1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source      : spat_1054bb3e6fb1_66891.tif \n#> varname     : Tmax (Climate Hazards Center Tmax) \n#> names       : Tmax_1, Tmax_2, Tmax_3, Tmax_4, Tmax_5, Tmax_6, ... \n#> min values  :  FALSE,  FALSE,  FALSE,  FALSE,  FALSE,  FALSE, ... \n#> max values  :   TRUE,   TRUE,   TRUE,   TRUE,   TRUE,   TRUE, ... \n#> time (days) : 2012-01-01 to 2012-12-31\n```\n:::\n\n\n\nWe can use this to count the number of days above the 35°C threshold for\neach pixel in our raster. We simply need to sum the binary raster layers\nwithin each month to count the number of days that exceed the threshold\nat each pixel location.\n\n::: column-margin\nWhen treating logical values as numeric, `TRUE` is treated as a `1` and\n`FALSE` is treated as a `0`.\n:::\n\nHowever, we also need to account for the fact that not all months\ncontain the same number of days. We therefore produce a *proportion* of\neach month's days that meet our temperature threshold by dividing by the\nnumber of days in each month.\n\nFor binary data, this turns out to be the same as calculating a mean, so\nwe can use a similar approach as we did when calculating average monthly\ntemperature. The difference is that we now provide our binary raster\n(`ml_bin`) to the `tapp()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_prop <- tapp(ml_bin, fun = mean, index = \"months\")\n```\n:::\n\n\n\nOnce again, we end up with a `SpatRaster` with 12 layers. However, in\nthis case, each raster pixel reflects the proportion of days above 35°\nin that month.\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Function to build individual panels for a small-multiple map using \n# binned color scheme\nchirts_panel_binned <- function(x, \n                                panel_title = \"\",\n                                fill_label = \"\",\n                                show_scale = TRUE,\n                                ...) {\n  r_in <- mask(x, ml_borders_out, inverse = FALSE)\n  \n  ggplot() + \n    layer_spatial(r_in, alpha = 0.9, na.rm = TRUE) +\n    layer_spatial(ml_borders_neat, fill = NA, color = \"#eeeeee\") +\n    layer_spatial(ml_borders_out, fill = NA, color = \"#7f7f7f\") +\n    labs(subtitle = panel_title, fill = fill_label) +\n    scale_fill_chirts_b(...) +\n    theme_dhs_map(show_scale = show_scale) +\n    theme(\n      axis.text.x = element_blank(), \n      axis.text.y = element_blank(),\n      plot.subtitle = element_text(hjust = 0.5, size = 12),\n      panel.grid = element_blank(),\n      legend.ticks = element_blank()\n    )\n}\n\n# Split raster by layer\nr <- split_raster(ml_prop)\n\n# Create map panels\npanels <- purrr::pmap(\n  list(r, months, show_scale),\n  function(x, y, z) chirts_panel_binned(\n    x, \n    y, \n    z, \n    n.breaks = 8, \n    limits = c(0, 1), \n    fill_label = \"Proportion of Days Above 35°C\"\n  )\n)\n\n# Plot\nwrap_plots(panels) +\n  plot_layout(guides = \"collect\", ncol = 4) +\n  plot_annotation(\n    title = \"Proportion of Days Above Threshold\",\n    caption = \"Source: Climate Hazards Center Infrared Temperature with Stations\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/listing-img-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nThis approach reveals a bit more detail about the *consistency* of the\ntemperature exposure during certain months. As we can see, some months\nare spent almost entirely above 35°C across the country. This continual\nexposure may be more strongly related to health than the averages we\ncalculated in the section above.\n\n## 3. Heatwaves: Consecutive days above a temperature threshold\n\nContinual exposure to high temperatures likely has a more pronounced\nhealth impact than isolated hot days. Accordingly, most heatwave\ndefinitions attempt to identify **sequences** of days that meet certain\ntemperature criteria.\n\nWe can build upon our previous temperature metric to produce a simple\nheatwave definition that identifies all days that belong to a sequence\nof 3+ days in a row that all meet the 35°C threshold used earlier.\n\nHow should we go about identifying sequences of days? To simplify\nthings, let's pull out the daily CHIRTS values for a single pixel in our\nraster to use as an example:\n\n\n\n::: {.cell out.lines='3'}\n\n```{.r .cell-code}\n# Extract values from a single pixel of CHIRTS data\npx1 <- as.numeric(ml_chirts[1, 1])\n\npx1\n#>   [1] 22.08196 22.25259 24.63318 25.46410 25.11430 24.69748 25.71723 27.64781\n#>   [9] 25.00261 22.27929 24.83206 22.42412 24.87811 28.53550 27.20606 26.75240\n#>  [17] 22.12105 22.98229 20.55801 19.10251 20.74286 22.91010 22.37615 22.23903\n....\n```\n:::\n\n\n\nAs we demonstrated above, it's easy to identify the layers that are\nabove a given threshold:\n\n\n\n::: {.cell out.lines='3'}\n\n```{.r .cell-code}\npx1_bin <- px1 > 35\n\npx1_bin\n#>   [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n#>  [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n#>  [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n....\n```\n:::\n\n\n\nBut how do we extract *sequences* from this vector? One option is to\nexploit the features of [run-length\nencoding](https://en.wikipedia.org/wiki/Run-length_encoding). Run-length\nencoding represents a vector of values as a sequence of *runs* of a\nsingle value and the *length* of that run.\n\nWe can use the `rle()` function from base R to convert to run-length\nencoding:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npx1_rle <- rle(px1_bin)\n\npx1_rle\n#> Run Length Encoding\n#>   lengths: int [1:23] 81 1 16 1 30 11 3 3 7 1 ...\n#>   values : logi [1:23] FALSE TRUE FALSE TRUE FALSE TRUE ...\n```\n:::\n\n\n\nThe output shows us that the `px1_bin` vector starts with a run of 81\n`FALSE` values, then has a run of 1 `TRUE` value, then 16 `FALSE`\nvalues, and so on. As you can see, run-length encoding provides us both\nwith information about the *values* and the *sequencing* of our input\nvector.\n\nIf we define a heatwave as any sequence of 3+ days above the temperature\nthreshold, each heatwave will be represented by entries with a *value*\nof `TRUE` (days that exceeded the threshold) **and** a *length* (number\nof days in a row) of 3 or more. We can use logical operations to\nidentify whether each run is a heatwave or not:\n\n\n\n::: {.cell out.lines='3'}\n\n```{.r .cell-code}\n# Identify days that were above threshold and belonged to a 3+ day sequence\nis_heatwave <- px1_rle$values & (px1_rle$lengths >= 3)\n\nis_heatwave\n#>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\n#> [13] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n```\n:::\n\n\n\nSumming this vector will give us the number of unique *heatwave events*\nduring the year for this sample pixel:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is_heatwave)\n#> [1] 8\n```\n:::\n\n\n\nWe could also get the proportion of days that are within those heatwaves\nby summing the lengths of all the heatwave events and dividing by the\nnumber of total days:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract lengths for each heatwave event\nheatwave_lengths <- px1_rle$lengths[is_heatwave]\n\nheatwave_lengths\n#> [1]  11   3   4 101   4   8   3   7\n\n# Proportion of days belonging to a heatwave\nsum(heatwave_lengths) / length(px1)\n#> [1] 0.3852459\n```\n:::\n\n\n\n### Custom functions\n\nIf we want to calculate the proportion of heatwave days across our\nentire raster, we can again return to `tapp()`. However, there's no\nbuilt-in function (like `mean`) that we can use to do the processing we\nwalked through above.\n\nInstead, we must provide our own **custom function** to indicate the\nprocessing that `tapp()` should perform on each set of layers. To define\na function, we use the `function()` keyword along with several\n*arguments*.\n\n::: callout-note\n## Note\n\nA function's arguments are the input parameters that the user can set\nwhen calling the function.\n:::\n\nAt its simplest, all this requires is copying the code we've already\nwritten above (we've consolidated the code into single lines in some\ncases):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop_heatwave <- function(temps) {\n  # Convert to RLE of days above threshold\n  bin_rle <- rle(temps >= 35)\n  \n  # Identify heatwave events based on sequence length\n  is_heatwave <- bin_rle$values & (bin_rle$lengths >= 3)\n  \n  # Count heatwave days and divide by total number of days\n  sum(bin_rle$lengths[is_heatwave]) / length(temps)\n}\n```\n:::\n\n\n\nNote that we do the exact same processing as we did in our step-by-step\nwalkthrough. The only difference is that instead of using the `px1`\nvariable (which contains the values for a single pixel), we instead use\na more general argument, which we call `temps`. `temps` stands in for\nany arbitrary input vector that the function user can provide (we've\nnamed it `temps` to help make it clear that this should be a vector of\ntemperature values). This means that we can easily run the same\ncalculation on different vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract 2 pixels for demonstration\npx1 <- as.numeric(ml_chirts[1, 1])\npx2 <- as.numeric(ml_chirts[1, 2])\n\n# Calculate heatwave proportions for each pixel\nprop_heatwave(px1)\n#> [1] 0.3852459\n\nprop_heatwave(px2)\n#> [1] 0.3852459\n```\n:::\n\n\n\n#### Writing a more flexible function\n\nRight now, the user of the function has no way to modify the temperature\nthreshold or sequence length used in the heatwave definition, because\nthose values (`35` and `3`) are **hard-coded** into our function.\n\nIf we move these values to the function arguments, we allow the *user*\nto decide what values these parameters should take. Here is a modified\nversion of `prop_heatwave()` that does this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop_heatwave <- function(temps, thresh, n_seq) {\n  # Convert to RLE of days above threshold\n  bin_rle <- rle(temps >= thresh)\n  \n  # Identify heatwave events based on sequence length\n  is_heatwave <- bin_rle$values & (bin_rle$lengths >= n_seq)\n  \n  # Count heatwave days and divide by total number of days\n  sum(bin_rle$lengths[is_heatwave]) / length(temps)\n}\n```\n:::\n\n\n\nOur function now has a `thresh` argument and an `n_seq` argument. Where\nwe previously would have compared our input `temps` vector to the\nthreshold of `35`, we now compare it to the value the user provides to\n`thresh`. Similarly, where we previously would have used sequences of\nlength `3` or more, we now use the sequence length the user provides to\n`n_seq`.\n\nUsing the values of 35 and 3 produces the same heatwave proportion as\nabove:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop_heatwave(px1, thresh = 35, n_seq = 3)\n#> [1] 0.3852459\n```\n:::\n\n\n\nBut now we can easily change our inputs to calculate modified heatwave\ndefinitions. For instance, to find the proportion of days in 4+ day\nheatwaves of at least 37°C:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop_heatwave(px1, thresh = 37, n_seq = 4)\n#> [1] 0.3114754\n```\n:::\n\n\n\nThis example demonstrates how function arguments can be used to produce\na more *flexible* function that can be easily applied across a range of\ninput parameters. Building functions in this way has a bit of an\nup-front cost, but it often pays for itself by making your future\nanalysis much more robust and scalable.\n\n### Scaling up\n\nNow that we have a function to calculate our heatwave definition, we can\nprovide it to `tapp()` with our desired temperature threshold and\nsequence parameters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apply our custom heatwave counter to each month\nml_heatwave_prop <- tapp(\n  ml_chirts, \n  fun = function(x) prop_heatwave(x, thresh = 35, n_seq = 3), \n  index = \"months\"\n)\n```\n:::\n\n\n\n::: callout-note\n## Anonymous Function Syntax\n\nOur `fun` argument above is written in *anonymous function syntax*. It\nmay look a little complex, but remember that `tapp()` expects you to\nprovide a *function* to its `fun` argument. Whichever function you\nprovide should be a function of the vector of values for each pixel in\nthe input raster.\n\n`function(x) prop_heatwave(x, ...)` indicates that we want to provide\neach of these vectors `x` to our `prop_heatwave()` function (as the\n`temps` argument). The `thresh` and `n_seq` arguments are fixed across\nall pixels. (In this case, `x` is just a placeholder to reference the\nvector inputs to our function. We could just as easily use another name,\nbut `x` is traditional and concise.)\n\nWhy didn't we use this syntax in previous sections? Well, it turns out\nthat `fun = mean` was simply a shorthand. Writing\n`fun = function(x) mean(x)` would have also worked!\n:::\n\nLet's see what the distribution of heatwave days looks like under our\nlatest definition:\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Split raster by layer\nr <- split_raster(ml_heatwave_prop)\n\n# Create map panels\npanels <- purrr::pmap(\n  list(r, months, show_scale),\n  function(x, y, z) chirts_panel_binned(\n    x, \n    y, \n    z, \n    n.breaks = 8, \n    limits = c(0, 1),\n    fill_label = \"Proportion of days in a heatwave\"\n  )\n)\n\n# Plot\nwrap_plots(panels) +\n  plot_layout(guides = \"collect\", ncol = 4) +\n  plot_annotation(\n    title = \"Proportion of heatwave days\",\n    subtitle = \"Heatwaves as sequences of 3+ days of 35°C\",\n    caption = \"Source: Climate Hazards Center Infrared Temperature with Stations\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nBecause we've built a flexible `prop_heatwave()` function, we can easily\ncalculate a different heatwave definition. For heatwaves of 4+ days of\n37°C+, for instance:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_heatwave_prop2 <- tapp(\n  ml_chirts, \n  fun = function(x) prop_heatwave(x, thresh = 37, n_seq = 4), \n  index = \"months\"\n)\n```\n:::\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Split raster by layer\nr <- split_raster(ml_heatwave_prop2)\n\n# Create map panels\npanels <- purrr::pmap(\n  list(r, months, show_scale),\n  function(x, y, z) chirts_panel_binned(\n    x, \n    y, \n    z, \n    n.breaks = 8, \n    limits = c(0, 1),\n    fill_label = \"Proportion of days in a heatwave\"\n  )\n)\n\n# Plot\nwrap_plots(panels) +\n  plot_layout(guides = \"collect\", ncol = 4) +\n  plot_annotation(\n    title = \"Proportion of heatwave days\",\n    subtitle = \"Heatwaves as sequences of 4+ days of 37°C\",\n    caption = \"Source: Climate Hazards Center Infrared Temperature with Stations\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nIt can be difficult to see the differences side-by-side, but we can\nsubtract the output rasters to easily examine the differences between\nthe two definitions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nml_heatwave_diff <- ml_heatwave_prop2 - ml_heatwave_prop\n```\n:::\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Convert 0 values to NA for transparency\nNAflag(ml_heatwave_diff) <- 0\n\n# Split raster into layers\nr <- split_raster(ml_heatwave_diff)\n\n# Create map panels\npanels <- purrr::pmap(\n  list(r, months, show_scale),\n  function(x, y, z) chirts_panel_binned(\n    x, \n    y, \n    z, \n    pal = \"diff\", \n    n.breaks = 8, \n    limits = c(-1, 0),\n    fill_label = \"Difference in proportion of days in heatwave\"\n  )\n)\n\n# Plot\nwrap_plots(panels) +\n  plot_layout(guides = \"collect\", ncol = 4) +\n  plot_annotation(\n    title = \"Difference in heatwave proportion metrics\",\n    subtitle = \"37°C 4+ days vs. 35°C 3+ days heatwave definitions\",\n    caption = \"Source: Climate Hazards Center Infrared Temperature with Stations\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nAs we can see, modifying our definition does indeed produce meaningful\ndifferences in the prevalence of heatwave days in various parts of the\ncountry. Which definition is appropriate will depend on your particular\nresearch questions and aims. However, building custom functions into\nyour workflow will make it much easier to quickly compare different\ndefinitions, facilitating sensitivity analyses and robustness checks.\n\n# Up next\n\nThere are many temperature exposure concepts that we didn't address in\nthis post, like climatological normals, seasonality, humidity, and more.\nHowever, the techniques we introduced should give you a solid foundation\nfor building flexible workflows to compute environmental metrics that\nyou use commonly in your research.\n\nThis post is the first in a short series. In our next technical post,\nwe'll build on the metrics we produced here to demonstrate how we can\nuse the monthly environmental data in conjunction with the dates\nrecorded in DHS surveys.\n\nWe'll extract values for our temperature metrics at the locations of the\nsurvey responses and attach these values to our DHS records on a\nmonth-by-month basis. This will allow us to finally link time-specific\ntemperature values to individual births in the DHS!\n\n## Getting Help {.appendix}\n\nQuestions or comments? Check out the [IPUMS User\nForum](https://forum.ipums.org) or reach out to IPUMS User Support at\nipums\\@umn.edu.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}