{
  "hash": "76c1e42342c096f1888a1a7eda9479cd",
  "result": {
    "markdown": "---\ntitle: \"Attaching CHIRPS Precipitation Data to DHS Surveys\"\ndescription: |\n  Remotely sensed precipitation data can provide important context for\n  understanding the health outcomes reported in the DHS\nauthor:\n  - name: Finn Roberts\n    affiliation: Senior Data Analyst, IPUMS\n  - name: Matt Gunther\n    affiliation: Research Methodologist, NORC\ndate: 02-04-2024\ndate-modified: 04-15-2024\ncategories:\n  - CHIRPS\n  - Precipitation\n  - Climate \n  - Agriculture\n  - terra \n  - sf \n  - ggspatial\n  - R\nfig-width: 10\nfig-height: 8\nimage: index_files/figure-html/listing-img-1.png\nbibliography: references.bib\nopen-graph:\n  title: \"IPUMS DHS Research Hub — Attaching CHIRPS Precipitation Data to DHS Surveys\"\n  description: |\n    Remotely sensed precipitation data can provide important context for\n    understanding the health outcomes reported in the DHS\n  image: index_files/figure-html/listing-img-1.png\ntwitter-card:\n  title: \"IPUMS DHS Research Hub — Attaching CHIRPS Precipitation Data to DHS Surveys\"\n  description: |\n    Remotely sensed precipitation data can provide important context for\n    understanding the health outcomes reported in the DHS\n  image: index_files/figure-html/listing-img-1.png\n---\n\n\nWe know that health outcomes are significantly impacted by individuals'\nenvironmental context: excessive rainfall can flood local infrastructure\n[@Mirza2011]; warmer temperatures can expand the range of common disease\nvectors [@Martens1997]; and drought can decimate crop-growing\nregions.[@Lesk2016] However, survey data like those from [The DHS\nProgram](https://www.dhsprogram.com/) often provide only a limited view\nof the environmental trends in which individuals are embedded.\n\nDeveloping a more holistic understanding of the role of environmental\nconditions in health outcomes therefore requires integrating external\ndata sources with the survey data from DHS.\n\nIn this post we'll demonstrate how to obtain raw precipitation data from\nthe [Climate Hazards Center InfraRed Precipitation with Station\ndataset](https://www.chc.ucsb.edu/data/chirps) (CHIRPS) and attach that\ndata to survey responses from [IPUMS\nDHS](https://www.idhsdata.org/idhs/).\n\n# Outline\n\nAs a motivating example, we'll consider whether historical precipitation\nrates have an effect on child stunting in Burkina Faso, measured with\nheight-for-age Z-scores. Precipitation patterns in an area likely\ninfluence crop yields for local farms. Thus, by impairing food\nproduction, periods of low precipitation may also be related to child\nstunting.\n\n::: column-margin\nThe height-for-age Z-score represents the difference between the child's\nheight and the median height of a reference population of the same age\nand sex, expressed in standard deviation units.\n:::\n\nTo address this question, we will first need to gather data from several\nsources. In the [Data sources] section, we demonstrate how to obtain\n\n-   DHS survey data from IPUMS DHS.\n-   GPS coordinate data for DHS survey areas from The DHS Program.\n-   daily precipitation data for 2001-2010 from CHIRPS.\n\nNext, in the [Summarize precipitation values] section, we'll summarize\nthe daily precipitation data in the area around each DHS survey\nlocation. To do this, we'll\n\n-   average the daily precipitation values across the 10-year time\n    period to produce an estimate of the average millimeters of rainfall\n    per day.\n-   define a buffer region around each DHS survey location, allowing us\n    to capture the trends in precipitation in the general vicinity of\n    each survey location.\n-   aggregate the precipitation data spatially to produce a single\n    estimate of the average daily precipitation for each DHS survey\n    area.\n\nFinally, in the [Join data sources] section, we'll attach the aggregated\nprecipitation values for each survey area to the DHS survey responses\nfrom that area.\n\n\n::: {.cell}\n\n:::\n\n\n# Data sources\n\n## IPUMS DHS survey data\n\nTo get started, we'll download a data file (or *extract*, in IPUMS\nterms) from IPUMS DHS and load it into R. The extract in this post\ncontains the `HWHAZWHO` variable (which contains the height-for-age\nZ-score) along with several pre-selected variables for the **2010\nBurkina Faso** sample. If you need a refresher on how to download IPUMS\nDHS data, see the [Downloading IPUMS DHS\nData](../2024-02-02-download-dhs-data/index.html) post.\n\n::: column-margin\n`<div class=\"hex\">\n<a href=\"https://tech.popdata.org/ipumsr/\" class=\"hex\">\n<img src=\"../../images/hex/ipumsr.png\" class=\"hex-img\"/>\n</a>\n<p class=\"hex-cap\">© IPUMS (MPL-2.0)</p>\n</div>`{=html}\n:::\n\nWe've downloaded and stored our XML codebook and compressed data file in\nthe `data/dhs` directory. Be sure to update this path based on your\nlocal file setup, so you can follow along.\n\nTo simplify our output, we'll select only a subset of the variables\nincluded in the extract:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ipumsr)\nlibrary(dplyr)\n\n# Load IPUMS DHS extract\ndhs <- read_ipums_micro(\n  ddi = \"data/dhs/idhs_00018.xml\",\n  data_file = \"data/dhs/idhs_00018.dat.gz\",\n  verbose = FALSE\n)\n\n# Select a subset of variables\ndhs <- dhs |> \n  select(SAMPLE, YEAR, IDHSPID, IDHSHID, DHSID, URBAN, HWHAZWHO)\n\ndhs\n#> # A tibble: 15,044 × 7\n#>    SAMPLE                     YEAR IDHSPID      IDHSHID DHSID URBAN   HWHAZWHO  \n#>    <int+lbl>                 <int> <chr>        <chr>   <chr> <int+l> <int+lbl> \n#>  1 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… -264      \n#>  2 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… -113      \n#>  3 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur…  -13      \n#>  4 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… -291      \n#>  5 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… -211      \n#>  6 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… 9999 [NIU…\n#>  7 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… 9999 [NIU…\n#>  8 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… -185      \n#>  9 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur… 9999 [NIU…\n#> 10 85404 [Burkina Faso 2010]  2010 85404      … 85404 … BF20… 2 [Rur…  -88      \n#> # ℹ 15,034 more rows\n```\n:::\n\n\nThis gives us a tabular data source containing 15,044 individual DHS\nsurvey responses for 7 variables. Of particular note is the `DHSID`\nvariable (which stores the identifier for the location of the survey\nresponse).\n\n## DHS cluster coordinates\n\nTo meaningfully attach environmental data to our DHS survey responses,\nwe'll need to know the location where each survey response was\ncollected. Fortunately, the DHS Program provides GPS coordinates for\neach surveyed household grouping, or *cluster*.\n\n::: {#displacement-rules .callout-important}\n## DHS Cluster Displacement\n\nIt's important to note that the GPS coordinates provided by The DHS\nProgram do not actually reflect the exact location of the clusters. In\nfact, the coordinates provided are **randomly displaced** from their\ntrue locations, such that:\n\n-   urban clusters are displaced up to 2 kilometers in any direction.\n-   99% of rural clusters are displaced up to 5 kilometers in any\n    direction.\n-   1% of rural clusters are displaced up to 10 kilometers in any\n    direction.\n-   displaced coordinates do not cross the country boundary and stay\n    within the DHS survey region.\n\nThe current demonstration doesn't require a precise location of each\ncluster, so we will ignore this detail. However, for more fine-grained\nanalyses (e.g. road network analyses), you may need to take displacement\ninto account.\n\nSee the DHS [GPS data\ncollection](https://www.dhsprogram.com/Methodology/GPS-Data.cfm)\ndocumentation for more details about the DHS cluster point displacement\nmethodology.\n:::\n\nIPUMS DHS does not yet disseminate DHS cluster coordinates directly. For\nnow, to obtain the GPS coordinates for a specific sample, you’ll have to\n[log\ninto](https://dhsprogram.com/data/dataset_admin/login_main.cfm?CFID=213299554&CFTOKEN=6d266879cd82102d-25F5B67E-C2E2-57E8-ECA142BF3516BEDD)\nyour account from The DHS Program. Specify your country of interest,\nand, on the line for the appropriate sample year, click the link to\ndownload the GPS coordinate data under the heading **GPS Datasets**.\n(Again, for this example, we're using Burkina Faso's 2010 sample.)\n\n::: column-margin\nIPUMS DHS has recently received permission and funding to distribute DHS\nGPS data. Stay tuned, as these data will soon be available via IPUMS!\n:::\n\nYou'll be presented with a new page containing a list of download links.\nScroll down to the **Geographic Datasets** section. You have the option\nof downloading the file as either a shapefile (.shp) or a comma\ndelimited file (.csv). For our purposes, we will download the\n**shapefile**, which contains spatial information in a format that can\nbe easily interpreted by R (as well as by external GIS software).\n\nFor the Burkina Faso 2010 sample, the file should be named `BFGE61FL`.\nIf you see a different file name, make sure you're working with the\ncorrect survey year.\n\n### Vector data\n\nOur DHS cluster coordinates are what's known as **vector data**. Vector\ndata refer to spatial data that represent geographic features using\ngeometric shapes like points, lines, and polygons.\n\n![Basic features of the vector data model [@Minn]](images/plp1.png)\n\nIn R, the `{sf}` package provides an intuitive tabular\nframework for working with vector data. sf objects look much like a\nfamiliar `{tibble}` or `data.frame`,\nbut also include an additional `geometry` column, which stores the\nspatial features that correspond to each set of observations.\n\n::: column-margin\n`<div class=\"hex\">\n<a href=\"https://r-spatial.github.io/sf/index.html\" class=\"hex\">\n<img src=\"../../images/hex/sf.png\" class=\"hex-img\"/>\n</a>\n<p class=\"hex-cap\">© Edzer Pebesma (GPL-2 | MIT)</p>\n</div>`{=html}\n:::\n\n<!-- ::: column-margin -->\n\n<!-- sf stands for \"[simple -->\n\n<!-- features](https://en.wikipedia.org/wiki/Simple_Features)\", a concept -->\n\n<!-- used commonly in geographic information systems (GIS). -->\n\n<!-- ::: -->\n\n#### Installing sf {#installing-sf}\n\nsf requires three **operating system dependencies**:\n\n-   [GEOS](https://trac.osgeo.org/geos) for geometrical operations on\n    projected coordinates\n-   [PRØJ](http://proj.org/) for coordinate reference system conversion\n    and transformation\n-   [GDAL](http://www.gdal.org/) for driver options\n\nMake sure to follow [these\ninstructions](https://r-spatial.github.io/sf/index.html#installing) to\nensure that you set up `GEOS`, `PRØJ`, and `GDAL` when installing sf.\nThe installation instructions may vary slightly, depending on your\noperating system. You may also need to update R, and then run\n`install.packages(\"sf\")`.\n\n### Loading cluster coordinates\n\nOnce sf is installed, we can use `st_read()` to load the file of GPS\ncoordinate data we downloaded above. We've stored our shapefile in the\n`data/gps` directory. Again, make sure to adjust this path based on the\nlocation where you saved the file on your own system.\n\n::: column-margin\nA shapefile is actually a *collection* of several files; the primary\nfile will have the .shp extension. Other files contain relevant metadata\nabout the geometries contained in the .shp file (for instance,\nprojection or index information).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n\n# Load the 2010 BF cluster coordinate shapefile\nbf_gps <- st_read(\"data/gps/BFGE61FL/BFGE61FL.shp\")\n#> Reading layer `BFGE61FL' from data source \n#>   `/Users/robe2037/Documents/projects/dhs-research-hub/posts/2024-02-04-dhs-chirps/data/gps/BFGE61FL/BFGE61FL.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 573 features and 20 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: -5.426079 ymin: 5.684342e-14 xmax: 1.957316 ymax: 14.86258\n#> Geodetic CRS:  WGS 84\n```\n:::\n\n\nOur resulting dataset looks something like a `tibble`, except that it\ncontains a header describing a **simple feature collection** with 573\n*features* and 20 *fields*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf_gps\n#> Simple feature collection with 573 features and 20 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: -5.426079 ymin: 5.684342e-14 xmax: 1.957316 ymax: 14.86258\n#> Geodetic CRS:  WGS 84\n#> First 10 features:\n#>             DHSID DHSCC DHSYEAR DHSCLUST CCFIPS ADM1FIPS ADM1FIPSNA ADM1SALBNA\n#> 1  BF201000000001    BF    2010        1     UV     NULL       NULL       NULL\n#> 2  BF201000000002    BF    2010        2     UV     NULL       NULL       NULL\n#> 3  BF201000000003    BF    2010        3     UV     NULL       NULL       NULL\n#> 4  BF201000000004    BF    2010        4     UV     NULL       NULL       NULL\n#> 5  BF201000000005    BF    2010        5     UV     NULL       NULL       NULL\n#> 6  BF201000000006    BF    2010        6     UV     NULL       NULL       NULL\n#> 7  BF201000000007    BF    2010        7     UV     NULL       NULL       NULL\n#> 8  BF201000000008    BF    2010        8     UV     NULL       NULL       NULL\n#> 9  BF201000000009    BF    2010        9     UV     NULL       NULL       NULL\n#> 10 BF201000000010    BF    2010       10     UV     NULL       NULL       NULL\n#>    ADM1SALBCO ADM1DHS ADM1NAME DHSREGCO          DHSREGNA SOURCE URBAN_RURA\n#> 1        NULL    9999     NULL       13         Sud-Ouest    GPS          R\n#> 2        NULL    9999     NULL        2          Cascades    GPS          R\n#> 3        NULL    9999     NULL       13         Sud-Ouest    GAZ          U\n#> 4        NULL    9999     NULL       10              Nord    GPS          R\n#> 5        NULL    9999     NULL        1 Boucle de Mouhoun    GPS          R\n#> 6        NULL    9999     NULL        6      Centre-Ouest    GPS          R\n#> 7        NULL    9999     NULL       12             Sahel    GPS          R\n#> 8        NULL    9999     NULL        3            Centre    GPS          U\n#> 9        NULL    9999     NULL        4        Centre-Est    GPS          U\n#> 10       NULL    9999     NULL        5       Centre-Nord    GAZ          R\n#>       LATNUM   LONGNUM ALT_GPS ALT_DEM DATUM                   geometry\n#> 1  10.109415 -2.807555     269     269 WGS84 POINT (-2.807555 10.10942)\n#> 2  10.388513 -3.907798     367     362 WGS84 POINT (-3.907798 10.38851)\n#> 3   9.882864 -2.925703    9999     308 WGS84 POINT (-2.925703 9.882864)\n#> 4  13.573418 -2.163120     323     323 WGS84  POINT (-2.16312 13.57342)\n#> 5  12.453299 -3.461899     301     298 WGS84  POINT (-3.461899 12.4533)\n#> 6  12.045308 -2.083828     338     325 WGS84 POINT (-2.083828 12.04531)\n#> 7  14.354198 -0.672096     328     328 WGS84  POINT (-0.672096 14.3542)\n#> 8  12.311034 -1.562071     322     324 WGS84 POINT (-1.562071 12.31103)\n#> 9  11.780763 -0.363904     317     304 WGS84 POINT (-0.363904 11.78076)\n#> 10 13.225114 -1.337994    9999     343 WGS84 POINT (-1.337994 13.22511)\n```\n:::\n\n\nEach feature corresponds to one cluster location for which we have GPS\ncoordinates, and each field represents a variable measured for each\ncluster. At the end of the output, you'll also notice the aforementioned\n`geometry` column that contains the latitude and longitude for each\ndisplaced cluster location.\n\nSome clusters contain unverified coordinates and have been assigned a\nlocation of (0, 0). Since we have no way of linking these clusters to\nenvironmental data, we will remove them for this analysis using dplyr's\n`filter()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove empty geographies\nbf_gps <- bf_gps |> \n  filter(LATNUM != 0, LONGNUM != 0)\n```\n:::\n\n\n### Visualizing spatial data {#visualizing}\n\nIt's always worth double-checking that spatial data are being processed\nas expected, and this is often most easily done visually. We'll use the\n`{ggspatial}` package to visualize our spatial data. This\npackage is a convenient extension of the popular `{ggplot2}`\npackage.\n\n::: column-margin\n`<div class=\"hex\">\n<a href=\"https://ggplot2.tidyverse.org/index.html\" class=\"hex\">\n<img src=\"../../images/hex/ggplot2.png\" class=\"hex-img\"/>\n</a>\n<p class=\"hex-cap\">© RStudio, Inc. (MIT)</p>\n</div>`{=html}\n:::\n\nAs with ggplot2, ggspatial allows us to think of our plot in layers. The\nprimary difference is that ggspatial's `layer_spatial()` automatically\nmaps the plot's x and y dimensions to the geographic coordinates in the\ndata.\n\n::: callout-note\n## ggplot2 and Themes\n\nThis post isn't intended to be an introduction to ggplot2, so don't\nworry if some of the plot code is unfamiliar to you—you should still be\nable to follow along with the other content in the post.\n\nAlso, we've modified some of the default theme elements for use in our\nplots throughout this post. We won't cover all the details here, but\nnote that your plots will likely look a bit different if you're\nfollowing along. For more about themes, see the associated\n[documentation](https://ggplot2.tidyverse.org/reference/theme.html).\n:::\n\nTo add some context to our map, we'll load a shapefile containing the\nBurkina Faso administrative borders. We'll use the integrated\ngeographies provided by IPUMS, which can be downloaded by clicking the\n**shapefile** link under the **Burkina Faso** section of [this\ntable](https://www.idhsdata.org/idhs/gis.shtml). We've placed this\nshapefile alongside our DHS coordinate data in our `data/gps` directory,\nand can load it with `st_read()`, as we did before:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load administrative boundary shapefile\nbf_borders <- st_read(\n  \"data/gps/geo_bf2003_2010/geo_bf2003_2010.shp\",\n  quiet = TRUE\n)\n```\n:::\n\n\nNow, we can plot the cluster locations (stored in `bf_gps`) along with\nthe Burkina Faso administrative boundaries (stored in `bf_borders`):\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggspatial)\n\n# Create map with cluster locations and BF boundaries \nggplot() +\n  layer_spatial(bf_borders, fill = NA) +\n  layer_spatial(bf_gps, size = 2, alpha = 0.4) +\n  labs(\n    title = \"Approximate DHS Cluster Locations\", \n    subtitle = \"Burkina Faso: 2010\",\n    caption = \"Source: DHS Program\"\n  ) +\n  annotation_scale(\n    aes(style = \"ticks\", location = \"br\"), \n    text_col = \"#999999\",\n    line_col = \"#999999\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nSo far, everything seems to be working as expected---all the cluster\npoints fall within the national borders, and there are noticeably more\npoints in known urban areas, like the capital region of Ouagadougou. We\nshould be safe to continue and load our precipitation data.\n\n## CHIRPS precipitation data\n\nFor this post, we will use precipitation data from\n[CHIRPS](https://www.chc.ucsb.edu/data/chirps), a quasi-global gridded\nrainfall time eries with data from 1981 to the near-present.[@Funk2015]\nCHIRPS is frequently used in health, agricultural, and hydrological\nresearch because of its relatively high spatial and temporal resolution,\nand validation studies have shown it to perform better than other\nleading precipitation models across several metrics.[@Pena-Guerrero2022;\n@Pyarali2022]\n\nImportantly, the CHIRPS data are provided as **raster data**, not vector\ndata. Instead of representing precipitation with a set of polygons or\npoints (as with vector data), raster data represent geographic features\nin a *grid*, where each cell in the grid is associated with a particular\nvalue. In our case, each cell is associated with a single daily\nprecipitation value (in millimeters).\n\n![Comparison of vector and raster data models [@Minn]](images/plp2.png)\n\nsf doesn't provide support for raster data---instead, we'll turn to the\n`{terra}` package.\n\n### Raster data\n\nterra has rapidly become the go-to R package for working with raster\ndata, and it is set to supersede the raster package, which was formerly\nused for raster operations.\n\n::: column-margin\n`<div class=\"hex\">\n<a href=\"https://rspatial.github.io/terra/index.html\" class=\"hex\">\n<img src=\"../../images/hex/terra.png\" class=\"hex-img\"/>\n</a>\n<p class=\"hex-cap\">© Robert J. Hijmans et al. (GPL &gt;=3)</p>\n</div>`{=html}\n:::\n\nIn most cases, terra provides much faster processing than does the\nraster package. The magic behind terra is that it avoids reading many\nraster images into R at once. Instead, it reads *metadata* about each\nimage---information about its spatial extent, coordinate reference\nsystem, pixel count, and so on.\n\n::: callout-warning\n## raster Package Retirement\n\nAt the time of writing, the raster package is still available on CRAN,\nbut it will be retired soon. You may see other resources referencing the\nraster package, but we suggest relying only on terra to ensure that your\ncode is robust to the upcoming retirement.\n:::\n\n#### Installing terra\n\nYou'll need the same operating system [dependencies](#installing-sf)\nrequired for sf to use terra to its full potential. If you've already\ngot those set up for sf, it should be easy to install terra with\n`install.packages(\"terra\")`. If not, follow [these\ninstructions](https://rspatial.github.io/terra/index.html#installation)\nto set up the package.\n\n### Loading CHIRPS data\n\nThe complete CHIRPS precipitation data series can be downloaded directly\nfrom the [UCSB Climate Hazards\nCenter](https://data.chc.ucsb.edu/products/CHIRPS-2.0/). However,\nbecause storing global data can require significant space, most users\nwill likely want to download data for a specific area of interest.\n\nThere are two primary ways to go about downloading CHIRPS data for a\nparticular area:\n\n1.  Select data interactively through the CHIRPS API provider:\n    [ClimateSERV](https://climateserv.servirglobal.net/). ClimateSERV\n    hosts a graphical user interface (GUI) that allows you to select an\n    area of interest on a map.\n2.  Access data through the CHIRPS API using the API client tools\n    provided by the `{chirps}` package.\n\nThe first option has the advantage of being visual and intuitive.\nHowever, if you need to update your data for a new area or time range,\nyou'll have to go through the manual download process again.\n\nIn contrast, the second option prioritizes reproducibility and\nadaptability: updating the data used in your analysis is a matter of\nadjusting just a few lines of code. However, your R session will be\noccupied while downloading data, which can take a fair amount of time\nfor long time series.\n\n#### Option 1: ClimateSERV\n\nFirst, navigate to the [ClimateSERV\nMap](https://climateserv.servirglobal.net/map). From there, open the\n*Statistical Query* toolbar on the top of the left sidebar and click\n**Select**. Click **Country** under the *Select features by* dropdown.\nThen, click on the country of interest---in this case, Burkina Faso (in\nWest Africa).\n\n::: callout-warning\nThe ClimateSERV interface may not work properly on all web browsers\n(e.g. Firefox). If you have difficulty, try opening the interface in a\ndifferent browser.\n:::\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/climateserv2.png){fig-align='center' width=1002}\n:::\n:::\n\n\nOnce you've indicated the country of interest, change the type of\nrequest to **Download Raw Data** and the download format to **TIF**.\nFinally, adjust the date range to start on **01/01/2001** and end on\n**12/31/2010**. This will give us a 10-year range running up to the\nsurvey year, allowing us to calculate a long-run average.\n\nFinally, click **Submit Query** to download the daily rainfall totals.\nNote that downloading this much data may take a fair amount of time!\n\n\n\n\n\nOnce your request has been processed, you'll receive a compressed (.zip)\nfolder containing one TIF image for each day in the time span: that's\n3652 files containing many megabytes of raster data. We've placed the\n.zip file in the `data` directory and renamed it `chirps.zip`. You can\nunzip the file in R with `unzip()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unzip and place individual .tif files in a new `data/chirps` directory\nchirps_files <- unzip(\"data/chirps.zip\", exdir = \"data/chirps\")\n```\n:::\n\n\nOr, if you prefer to unzip the file manually, you can do so and then\nlist the individual raster files with `list.files()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create list of paths to all individual raster files\nchirps_files <- list.files(\"data/chirps\", full.names = TRUE)\n```\n:::\n\n\nWe can load raster files with the `rast()` function from terra. When\nproviding multiple files, terra will stack them so each input file\nbecomes a single layer in a larger **raster stack**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n\n# Load set of .tif files into into a single raster stack\nbf_precip <- rast(chirps_files)\n```\n:::\n\n\n#### Option 2: The chirps package\n\nWe can use the `get_chirps()` function from the `{chirps}`\npackage to access CHIRPS data via the CHIRPS API. Since we don't have a\nmap where we can select our region of interest, we'll have to provide a\npre-loaded region representing the area for which we'd like data.\n\nWe can use the `bf_borders` object we created earlier to get data for\nthe Burkina Faso region. We'll use `vect()` to convert it to a\n`SpatVector` from terra (`get_chirps()` currently has more robust\nsupport for these objects). We'll also input our desired date range for\nwhich to obtain data:\n\n::: column-margin\nThe `SpatVector` is the main object terra uses to represent vector data.\nWe've already shown how to use sf to handle vector data, but terra also\nprovides support for this data model. In general, we find that sf's\nvector objects are a little more intuitive, but there are some cases\nwhere using terra may make certain operations easier or faster.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the chirps package\nlibrary(chirps)\n\n# Get CHIRPS data from 2001-2010 for Burkina Faso \nbf_precip <- get_chirps(\n  vect(bf_borders),\n  dates = c(\"2001-01-01\",\"2010-12-31\"),\n  server = \"CHC\" # Recommended when obtaining data for multiple dates and/or locations\n)\n```\n:::\n\n\n`get_chirps()` obtains data for a rectangular region around the country.\nFor consistency with the results you would get from ClimateSERV (which\nonly downloads data within the country borders), we'll use terra's\n`mask()` function to remove data from outside the Burkina Faso borders:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf_precip <- mask(bf_precip, bf_borders, touches = FALSE)\n```\n:::\n\n\n::: callout-note\n## ClimateSERV vs. chirps\n\nThere may be some trivial discrepancies between the data obtained via\nClimateSERV and those obtained via the chirps package. When creating\nthis post, we used data obtained via ClimateSERV.\n\nIf you instead obtained data from chirps, your values may differ\nslightly from those we present below. These differences shouldn't\nmeaningfully affect any of the operations we demonstrate.\n:::\n\n### `SpatRaster` objects\n\nRegardless of the method you chose to access the CHIRPS data, you should\nnow have a `SpatRaster` object from terra containing the raster stack of\nprecipitation data covering the entirety of Burkina Faso from 2001 to\n2010:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf_precip\n#> class       : SpatRaster \n#> dimensions  : 115, 159, 3652  (nrow, ncol, nlyr)\n#> resolution  : 0.05, 0.05  (x, y)\n#> extent      : -5.549997, 2.400003, 9.349999, 15.1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> sources     : 20010101.tif  \n#>               20010102.tif  \n#>               20010103.tif  \n#>               ... and 3649 more source(s)\n#> names       : 20010101, 20010102, 20010103, 20010104, 20010105, 20010106, ...\n```\n:::\n\n\nAs you can see, this raster layer contains 115 rows and 159 columns of\npixels. The value in each pixel represents the rainfall (in millimeters)\nfor an area 0.05 degrees longitude by 0.05 degrees latitude (shown in\nthe `resolution` field).\n\nEach of the 3652 layers in the `SpatRaster` represents the CHIRPS\nprecipitation values for a single day of the 10-year period between 2001\nand 2010.\n\nTo better understand this structure, we can visualize the rainfall\npatterns for one of these days. We'll first need to select an individual\nlayer from the raster stack. We can index layers by name or layer\nposition using `[[` notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select a single layer\n# (Layer names will vary depending on how you obtained your CHIRPS data)\nprecip_day <- bf_precip[[\"20010719\"]]\n```\n:::\n\n\nOnce we've selected a layer, we can use `layer_spatial()` to plot it,\njust as we did for vector objects.\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Create map of rainfall for single day\nggplot() +\n  layer_spatial(\n    precip_day, \n    alpha = if_else(values(precip_day) == 0, 0, 0.8), \n    na.rm = TRUE\n  ) +\n  layer_spatial(bf_borders, fill = NA, color = \"#888888\") +\n  layer_spatial(bf_gps,  fill = NA, size = 2, alpha = 0.4) +\n  labs(\n    title = \"Burkina Faso Rainfall: July 19, 2001\",\n    subtitle = \"CHIRPS precipitation data with DHS cluster locations\",\n    fill = \"Rainfall total (mm)\",\n    caption = \"Source: DHS Program and Climate Hazards Center InfraRed Precipitation with Station (CHIRPS)\"\n  ) +\n  annotation_scale(\n    aes(style = \"ticks\", location = \"br\"), \n    text_col = \"#999999\",\n    line_col = \"#999999\"\n  ) +\n  scale_fill_gradient(low = \"white\", high = \"#00263A\", na.value = NA)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nIt can be unwieldy to manage many layers of raster data. In the next\nsection, we'll introduce methods for simplifying these data across both\ntime and space so they can be more easily attached to our DHS survey.\n\n# Summarize precipitation values {data-link=\"Summarize precipitation values\"}\n\nThe terra package contains several [summary\nmethods](https://rspatial.github.io/terra/reference/summarize-generics.html)\nwe can use to quickly explore summary statistics across all of the\nlayers included in our multi-year timespan. For example, `mean()`\ncomputes the mean daily precipitation value for each pixel location\nacross all layers (days) of our CHIRPS data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate mean daily precipitation value for each pixel (mm/day)\nbf_precip_mean <- mean(bf_precip)\n\nbf_precip_mean\n#> class       : SpatRaster \n#> dimensions  : 115, 159, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.05, 0.05  (x, y)\n#> extent      : -5.549997, 2.400003, 9.349999, 15.1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source(s)   : memory\n#> name        :      mean \n#> min value   : 0.8771938 \n#> max value   : 3.1498873\n```\n:::\n\n\nNotice that this produces another `SpatRaster` and that the result only\nhas one layer. This makes sense, because `mean()` uses all of the input\nraster layers to produce a single average precipitation (in millimeters\nper day) for each cell.\n\nSince `mean()` produces another `SpatRaster`, we can plot the average\nvalues for the 10-year time span just as we did with a single day's\nworth of precipitation data:\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nggplot() +\n  layer_spatial(bf_precip_mean, alpha = 0.8, na.rm = TRUE) +\n  layer_spatial(bf_borders, alpha = 0) +\n  labs(\n    title = \"Burkina Faso Average Rainfall: 2001-2010\",\n    subtitle = \"CHIRPS precipitation data\",\n    fill = \"10-year average rainfall (mm/day)\",\n    caption = \"Source: Climate Hazards Center InfraRed Precipitation with Station (CHIRPS)\"\n  ) +\n  annotation_scale(\n    aes(style = \"ticks\", location = \"br\"),\n    text_col = \"#999999\",\n    line_col = \"#999999\"\n  ) +\n  scale_fill_gradient(low = \"#FAEFD1\", high = \"#00263A\", na.value = NA)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nAt this point, our primary data sources still remain completely\nindependent. We know the approximate location of the DHS clusters, and\nwe have a summary of the average daily precipitation across Burkina\nFaso, but we haven’t linked the two together to create a specific\nprecipitation record for each cluster.\n\nOur remaining task is to **extract** the mean precipitation values from\nthe CHIRPS raster at each of the DHS cluster locations.\n\n## Cluster buffers\n\nWe might think it logical to extract the mean precipitation values at\neach cluster's point location. However, recall that our motivating\nquestion centered around the idea that precipitation influences health\nby way of impacting local crop yields. The farms that serve the\npopulation of a given cluster won't necessarily be situated right at the\nrecorded cluster location. Furthermore, each farm is probably impacted\nby the precipitation patterns in its surrounding area, not only those\nthat occur at its exact location.\n\nWith this in mind, it makes sense to generate a summary metric of the\nprecipitation in the *general area* of each cluster, rather than at the\ncluster point locations. We can accomplish this by creating **buffer\nzones** around each cluster coordinate.\n\nWe can use `st_buffer()` to create an appropriately sized buffer zone\naround the displaced GPS coordinates for each cluster. However, sf's\ngeometrical operations (powered by GEOS) assume that the input data are\nin *meters*, and our data are currently in *degrees*.\n\nTherefore, we first need to **project** our GPS coordinates into a new\ncoordinate reference system, or CRS. We will use the [UTM Coordinate\nSystem](https://pubs.usgs.gov/fs/2001/0077/report.pdf) Zone 30N for our\nprojection, which provides limited distortion for Burkina Faso. The\n[EPSG](https://epsg.io/about) code for this UTM zone is 32630, which we\ncan provide to `st_transform()` to project our data:\n\n::: column-margin\nMap projections constitute an entire topic on their own. To learn more\nabout projected coordinate systems, there are countless resources\nonline, like [this\ntreatment](http://downloads2.esri.com/support/documentation/ao_/710Understanding_Map_Projections.pdf)\nfrom [ESRI](https://www.esri.com/en-us/home)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Project cluster locations to the UTM 30N reference system\nbf_gps <- st_transform(bf_gps, crs = 32630)\n```\n:::\n\n\nWe can use `st_geometry()` to see a summary of our sf object's geometry.\nNote that the `Projected CRS` now shows `UTM zone 30N`, and that our\ndata are now stored in meters, rather than degrees:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry(bf_gps)\n#> Geometry set for 541 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 234659.3 ymin: 1092462 xmax: 1039190 ymax: 1645174\n#> Projected CRS: WGS 84 / UTM zone 30N\n#> First 5 geometries:\n#> POINT (521084.1 1117516)\n#> POINT (400626 1148510)\n#> POINT (508145.5 1092462)\n#> POINT (590542.4 1500704)\n#> POINT (449803.2 1376723)\n```\n:::\n\n\n::: column-margin\nIf you need to check your work, you can always access the current CRS of\nyour data with `st_crs()`.\n:::\n\nNow that we're working in meters, we can buffer our points using\n`st_buffer()`. The appropriate buffer distance will depend on your\nspecific research question of interest. For this demonstration, we'll\ncreate a 10-kilometer (10,000 meter) buffer by setting `dist = 10000`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf_gps <- st_buffer(bf_gps, dist = 10000)\n```\n:::\n\n\nWe see that the geometry column now describes `POLYGON` geometries\nrather than `POINT` geometries. Each polygon is defined by a series of\npoints that form the circumference of the buffer zone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry(bf_gps)\n#> Geometry set for 541 features \n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 224659.3 ymin: 1082462 xmax: 1049190 ymax: 1655174\n#> Projected CRS: WGS 84 / UTM zone 30N\n#> First 5 geometries:\n#> POLYGON ((531084.1 1117516, 531070.3 1116993, 5...\n#> POLYGON ((410626 1148510, 410612.3 1147987, 410...\n#> POLYGON ((518145.5 1092462, 518131.8 1091939, 5...\n#> POLYGON ((600542.4 1500704, 600528.7 1500181, 6...\n#> POLYGON ((459803.2 1376723, 459789.5 1376200, 4...\n```\n:::\n\n\nWe're finished measuring distance in meters, so we'll again use\n`st_transform()` to revert back to degrees of latitude and longitude\n(EPSG 4326) for consistency with our other maps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf_gps <- st_transform(bf_gps, crs = 4326)\n```\n:::\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nggplot() + \n  layer_spatial(bf_borders, fill = NA) +\n  layer_spatial(bf_gps, fill = \"black\", alpha = 0.2) +\n  labs(\n    title = \"Buffered DHS Cluster Locations\",\n    subtitle = \"Burkina Faso: 2010\",\n    caption = \"Source: DHS Program\"\n  ) +\n  annotation_scale(\n    aes(style = \"ticks\", location = \"br\"), \n    text_col = \"#999999\",\n    line_col = \"#999999\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n::: callout-tip\n## Handling cluster displacement\n\nPreviously, we discussed the fact that the cluster coordinates provided\nby The DHS Program are [displaced](#displacement-rules) from their true\nlocations. While we don't need to address this for our precipitation\ndata, there may be other cases where it is useful to obtain a more\nprecise location for each cluster (for instance, if working with road\nnetworks or other fine-grained data).\n\nIn these cases, you can certainly buffer points conditionally on other\nvalues in the data by providing a conditional statement to the buffer\n`dist` argument. For instance, to buffer urban clusters\n(`URBAN_RURA == \"U\"`) by 2000 meters and other clusters by 5000 meters,\nuse an `if_else()` statement:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_buffer(\n  bf_gps, \n  dist = if_else(bf_gps$URBAN_RURA == \"U\", 2000, 5000)\n)\n```\n:::\n\n:::\n\n## Aggregating rainfall within cluster regions\n\nNow that we have buffered cluster regions, we can focus on combining our\ntwo data sources. Let's zoom in on a single cluster as an example. We'll\nuse the cluster with `DHSCLUST` number `160`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust <- bf_gps |> \n  filter(DHSCLUST == 160)\n```\n:::\n\n\nTo simplify this example, we'll use terra's `crop()` to restrict our\nraster to the cells surrounding this cluster:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprecip_clust <- crop(bf_precip_mean, clust, snap = \"out\")\n```\n:::\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nggplot() + \n  layer_spatial(precip_clust, alpha = 0.8) + \n  layer_spatial(clust, alpha = 0, linewidth = 0.5, color = \"black\") +\n  labs(\n    title = \"Average Rainfall: 2001-2010\",\n    subtitle = \"Single DHS cluster\",\n    fill = \"10-year average rainfall (mm/day)\",\n    caption = \"Source: DHS Program and Climate Hazards Center InfraRed Precipitation with Station (CHIRPS)\"\n  ) +\n  scale_fill_gradient(\n    low = \"#FAEFD1\", \n    high = \"#00263A\", \n    na.value = NA, \n    limits = c(2.3, 2.5)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n::: column-margin\nFor demonstration purposes, we've used different limits for the color\nscale in this plot and the next. In general, we'd want to ensure that\nthe colors in this plot map to the same values used in other plots with\nthe same color scheme.\n:::\n\nWe see a range of rainfall totals across the 20 pixels in this area. How\ncan we summarize the information contained in these individual pixels\ninto a single estimate of the rainfall for this buffered cluster region?\n\nThe most straightforward approach might be to take the mean of all the\npixel values that overlap our buffer region. First, we need to obtain\nthe values of the overlapping raster cells. We can use terra's\n`extract()` to obtain the raster cell values from the region defined by\nan overlapping vector data source (in this case, our example cluster,\n`clust`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextract(bf_precip_mean, clust)\n#>    ID     mean\n#> 1   1 2.337887\n#> 2   1 2.329431\n#> 3   1 2.344792\n#> 4   1 2.317271\n#> 5   1 2.343546\n#> 6   1 2.329051\n#> 7   1 2.381871\n#> 8   1 2.367312\n#> 9   1 2.395538\n#> 10  1 2.395361\n#> 11  1 2.402505\n#> 12  1 2.415130\n```\n:::\n\n\nNote that this provides mean daily precipitation values for 12 different\ncells. By default, `extract()` will only extract values from the cells\nwhose *center point* lies within the overlaid polygon:\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# New SpatRaster with same extent as bf_precip_mean, but with empty values\next_cells <- rast(bf_precip_mean, vals = NA)\n\n# ID cell locations for each cell that is extracted\ncell_idx <- extract(ext_cells, clust, cells = TRUE)$cell\n\next_cells[cell_idx] <- bf_precip_mean[cell_idx]\n\nggplot() + \n  layer_spatial(\n    crop(ext_cells, clust, snap = \"out\"), \n    alpha = 0.8, \n    na.rm = TRUE\n  ) +\n  layer_spatial(clust, alpha = 0, linewidth = 0.5, color = \"black\") +\n  labs(\n    title = \"Average Rainfall: 2001-2010\",\n    subtitle = \"Single DHS cluster\",\n    fill = \"10-year average rainfall (mm/day)\",\n    caption = \"Source: DHS Program and Climate Hazards Center InfraRed Precipitation with Station (CHIRPS)\"\n  ) +\n  scale_fill_gradient(\n    low = \"#FAEFD1\", \n    high = \"#00263A\", \n    na.value = NA, \n    limits = c(2.3, 2.5)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nTo instead include *all* cells that intersect the polygon, set\n`touches = TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust_precip <- extract(bf_precip_mean, clust, touches = TRUE)\n\nclust_precip\n#>    ID     mean\n#> 1   1 2.350189\n#> 2   1 2.319925\n#> 3   1 2.385132\n#> 4   1 2.337887\n#> 5   1 2.329431\n#> 6   1 2.328763\n#> 7   1 2.344792\n#> 8   1 2.317271\n#> 9   1 2.343546\n#> 10  1 2.329051\n#> 11  1 2.381871\n#> 12  1 2.367312\n#> 13  1 2.395538\n#> 14  1 2.395361\n#> 15  1 2.393321\n#> 16  1 2.402505\n#> 17  1 2.415130\n#> 18  1 2.395817\n```\n:::\n\n\nThis operation provides the mean daily precipitation values for each of\nthe 18 cells that intersect our cluster region. However, some cells\ncover a much larger portion of the cluster region than others. To\naccount for the heterogeneity in size, we can set `weights = TRUE` to\ninclude a `weight` column, which records the proportion of each cell\nthat is covered by the polygon:\n\n::: column-margin\n`weights = TRUE` automatically includes all intersected cells, but those\nwith negligible weights will be removed.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust_precip <- extract(bf_precip_mean, clust, weights = TRUE)\n\nclust_precip\n#>    ID     mean weight\n#> 1   1 2.385132   0.20\n#> 2   1 2.337887   0.90\n#> 3   1 2.329431   0.94\n#> 4   1 2.328763   0.33\n#> 5   1 2.344792   0.70\n#> 6   1 2.317271   1.00\n#> 7   1 2.343546   1.00\n#> 8   1 2.329051   0.86\n#> 9   1 2.381871   0.57\n#> 10  1 2.367312   1.00\n#> 11  1 2.395538   1.00\n#> 12  1 2.395361   0.74\n#> 13  1 2.393321   0.03\n#> 14  1 2.402505   0.47\n#> 15  1 2.415130   0.53\n#> 16  1 2.395817   0.09\n```\n:::\n\n\nWe can then provide the weights to the `weighted.mean()` function to\ncalculate a weighted mean that is shifted toward the cell values that\nform a larger proportion of the polygon area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweighted.mean(clust_precip$mean, clust_precip$weight)\n#> [1] 2.358508\n```\n:::\n\n\nBecause this kind of workflow is so common, terra provides a quicker\nshorthand in `extract()`. You can use the `fun` argument to specify an\naggregation function at the same time that you extract the raster cell\nvalues:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract area-weighted average for all cells covered by `clust`\nextract(\n  bf_precip_mean,\n  clust,\n  fun = \"mean\", # Average all extracted values\n  weights = TRUE # Use area weights\n)\n#>   ID     mean\n#> 1  1 2.358508\n```\n:::\n\n\nThe `2.358508` value represents the area-weighted mean of the 10-year\nmean precipitation values (in millimeters per day) within the given\ncluster region.\n\n### Scaling up for all clusters\n\nTo aggregate the rainfall data for each DHS cluster in the sample, we\nsimply scale up. We again use `extract()`, but we provide our raster of\nprecipitation values for the entire country and the polygons for all of\nour buffered clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Average the mean CHIRPS values within each DHS cluster\nclust_means <- extract(\n  bf_precip_mean,\n  bf_gps, # All clusters included\n  fun = \"mean\",\n  weights = TRUE,\n  na.rm = TRUE, # Ignore missing CHIRPS values\n  bind = TRUE # Recombine with original `bf_gps` data\n)\n```\n:::\n\n\nBy setting `bind = TRUE`, we can automatically recombine the extracted\nmeans with the other cluster data in `bf_gps`.\n\nWe also set `na.rm = TRUE` to ensure we don't get missing values for\nclusters whose regions expand beyond the country borders (where we\nhaven't downloaded any CHIRPS data). This decision may be reasonable if\nour interest is in rainfall over local crop-producing regions, and we\ndon't believe that clusters in border regions obtain substantial inputs\nfrom farms outside of the country. (If we wanted to include the rainfall\noutside of the country borders, we would simply need to expand our\nbounding box when downloading our CHIRPS data.)\n\nFinally, we'll convert our cluster means back to an sf object. Notice\nthat there now exists a `mean` column that stores the weighted mean\nvalues for each cluster:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert to sf object\nclust_means <- st_as_sf(clust_means)\n\nclust_means |> \n  select(DHSID, mean, geometry)\n#> Simple feature collection with 541 features and 2 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -5.517451 ymin: 9.792417 xmax: 2.049008 ymax: 14.95288\n#> Geodetic CRS:  WGS 84\n#> First 10 features:\n#>             DHSID     mean                       geometry\n#> 1  BF201000000001 2.758146 POLYGON ((-2.71628 10.10935...\n#> 2  BF201000000002 2.782180 POLYGON ((-3.816453 10.3887...\n#> 3  BF201000000003 3.004422 POLYGON ((-2.834491 9.88283...\n#> 4  BF201000000004 1.678181 POLYGON ((-2.070699 13.5730...\n#> 5  BF201000000005 2.129466 POLYGON ((-3.369883 12.4534...\n#> 6  BF201000000006 2.203529 POLYGON ((-1.991964 12.0449...\n#> 7  BF201000000007 1.113443 POLYGON ((-0.579432 14.3532...\n#> 8  BF201000000008 2.110246 POLYGON ((-1.470133 12.3105...\n#> 9  BF201000000009 2.281224 POLYGON ((-0.2722169 11.779...\n#> 10 BF201000000010 1.722371 POLYGON ((-1.245736 13.2245...\n```\n:::\n\n\nNow that we have aggregated rainfall across all clusters, we can plot\nthe average rainfall for each of the 10-kilometer buffered cluster\nregions. Each cluster region is associated with a single 10-year average\nrainfall value.\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nggplot() + \n  layer_spatial(bf_borders, fill = NA) +\n  layer_spatial(clust_means, aes(fill = mean), alpha = 0.8) +\n  labs(\n    title = \"Average Rainfall within Clusters: 2001-2010\",\n    subtitle = \"Burkina Faso: 2010 Clusters\",\n    fill = \"10-year average rainfall (mm/day)\",\n    caption = \"Source: DHS Program and Climate Hazards Center InfraRed Precipitation with Station (CHIRPS)\"\n  ) +\n  annotation_scale(\n    aes(style = \"ticks\", location = \"br\"), \n    text_col = \"#999999\",\n    line_col = \"#999999\"\n  ) +\n  scale_fill_steps(low = \"#FAEFD1\", high = \"#00263A\", n.breaks = 4) +\n  theme(legend.ticks = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/listing-img-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n# Join data sources\n\nAt this point, we have our aggregated CHIRPS data merged with our DHS\n*clusters*, but not with the individual DHS survey *responses*.\n\nTo accomplish this last task, we need to merge the cluster means with\nthe survey responses, based on the cluster where each response was\nrecorded. This information is stored in the `DHSID` variable provided by\nIPUMS DHS.\n\nWe'll use dplyr's `right_join()` to merge the survey responses with the\nmean precipitation values for each cluster, matching records using their\n`DHSID` code. Using `right_join()` ensures that responses from clusters\nwith no location information (which have been filtered out of\n`clust_means`) are not included in the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join survey responses and cluster precipitation values, based on\n# the cluster where each response was recorded (DHSID)\ndhs_chirps <- right_join(\n  dhs,\n  st_drop_geometry(clust_means), # remove geometry for simplicity in output\n  by = \"DHSID\"\n)\n```\n:::\n\n\nNow we can finally link the 10-year mean precipitation value to each\nsample participant's outcomes. To demonstrate, we clean up the\n`HWHAZWHO` variable and visualize the relationship between 10-year\naverage precipitation and childrens’ height-for-age in Z-scores:\n\n::: column-margin\nipumsr includes helper functions to view the metadata for IPUMS\nvariables. For instance, `ipums_val_labels()` can show us the missing\nvalue codes for a given variable, which we can use when cleaning our\ndata.\n:::\n\n\n::: {.cell .column-screen-inset layout-align=\"center\"}\n\n```{.r .cell-code}\n# Clean up HWHAZWHO for plotting\ndhs_chirps_recode <- dhs_chirps |> \n  filter(HWHAZWHO < 9995) |> # Remove missing HWHAZWHO values\n  mutate(HWHAZWHO = HWHAZWHO / 100) # Recode decimal place based on IPUMS documentation\n\n# Create scatterplot of mean precipitation value vs. HWHAZWHO \nggplot() +\n  geom_point(\n    aes(x = mean, y = HWHAZWHO, fill = mean), \n    data = dhs_chirps_recode,\n    color = \"#999999\", \n    shape = 21,\n    size = 2,\n    alpha = 0.8\n  ) +\n  labs(\n    title = \"Average Rainfall and Stunting\",\n    subtitle = \"Burkina Faso: 2010 Clusters\",\n    x = \"10-year average rainfall (mm/day)\",\n    y = \"Height for Age Z-Score\",\n    fill = \"10-year average rainfall (mm/day)\",\n    caption = \"Source: IPUMS DHS, DHS Program, and Climate Hazards Center InfraRed Precipitation with Station (CHIRPS)\"\n  ) +\n  scale_fill_gradient(low = \"#FAEFD1\", high = \"#00263A\", na.value = NA) +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nSince our rainfall metric is now linked to each individual's survey\nresponse, we can include average rainfall as a predictor when analyzing\nthe health outcomes provided by IPUMS DHS.\n\n# Final thoughts\n\nThis post has introduced several core concepts for including spatial\ndata in an analysis, including:\n\n-   the distinction between vector and raster data\n-   the main packages (sf and terra) used for working with spatial data\n    in R\n-   methods for summarizing longitudinal spatial data across time\n-   spatial buffering and methods for aggregating raster values within\n    polygons\n-   the importance of considering the geographic context of spatial data\n    when deciding the most appropriate way to include such data in an\n    analysis\n\nThat being said, many of the techniques we introduced will be too\nsimplistic for most analyses.\n\nFor instance, a single long-run average is unlikely to capture much\nnuance in the way precipitation influences nutrition. Instead, it might\nbe more meaningful to determine precipitation patterns at the points in\nthe growing season when crops are most vulnerable. Or we could\ninvestigate local environmental conditions only for time periods\nsurrounding each child's birth.\n\nFurthermore, our CHIRPS data span until the end of 2010, but the health\ninterview responses come from *before* the end of 2010, meaning that\nsome of our rainfall data can't possibly be causally linked to the\nhealth responses.\n\nUsing geographic data therefore requires careful planning and thought.\nNonetheless, the workflow and methods introduced in this post should\ngive you a solid foundation from which to start thinking about how to\nintegrate spatial data into analyses of IPUMS DHS data.\n\n## Getting Help {.appendix}\n\nQuestions or comments? Check out the [IPUMS User\nForum](https://forum.ipums.org) or reach out to IPUMS User Support at\nipums\\@umn.edu.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}