{
  "hash": "847de381b1f0034cc3e199ea1f5f98ac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Aggregation Methods for NDVI Data\"\ndescription: |\n    We use data from two regions to illustrate approaches to \n    processing NDVI data\nauthor: \n  - name: \"Finn Roberts\"\n    affiliation: \"IPUMS Senior Data Analyst\"\ndate: 08-16-2024\ncategories:\n  - NDVI\n  - Seasonality\n  - Climatological normals\n  - Agriculture\n  - Extreme weather\n  - Food production\n  - R\n  - Time series\n  - terra\n  - ggspatial\n  - sf\nfig-width: 10\nfig-height: 8\nimage: index_files/figure-html/listing-img-1.png\nopen-graph:\n  title: \"Aggregation Methods for NDVI Data\"\n  description: |\n    We use data from two regions to illustrate approaches to \n    processing NDVI data\n  image: index_files/figure-html/listing-img-1.png\ntwitter-card:\n  title: \"Aggregation Methods for NDVI Data\"\n  description: |\n    We use data from two regions to illustrate approaches to \n    processing NDVI data\n  image: index_files/figure-html/listing-img-1.png\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\nPreviously, we showed how to load NDVI data for two time points in Kenya\nusing NASA's Earthdata Search interface. If you're new to NDVI, we\nsuggest you go ahead and take a look at our [introductory\npost](../2024-07-02-ndvi-concepts) as well as our [NDVI data loading\npost](../2024-08-01-ndvi-data) before continuing.\n\nIn this post, we'll use two NDVI time series to demonstrate some of the\nconsiderations that emerge when aggregating and processing NDVI raster\ndata in the context of population health research. We need to conduct\nmany of the same aggregation steps for our NDVI data as we did for\nprevious data sources, like [CHIRPS](../2024-02-04-dhs-chirps) and\n[CHIRTS](../2024-04-15-chirts-metrics). However, as with any new data\nsource, the decisions we make about how to do so will vary when working\nwith NDVI.\n\nTo highlight some of the features of NDVI data, we'll load NDVI time\nseries from two capitals with different climates: Nairobi, Kenya and\nOuagadougou, Burkina Faso. We'll use a familiar workflow to build\nbuffers around the DHS cluster points in these regions and will extract\nNDVI time series for each. Once we have these time series, we'll use\nthem to explore how extreme weather and seasonality may play a role in\nthe way we aggregate NDVI data.\n\nAs always, we'll start by loading some of the packages used in the post:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggspatial)\nlibrary(patchwork)\nlibrary(lubridate)\n```\n:::\n\n\n\n\n\n# Data: Two capital regions\n\nWe'll be using NDVI data from the MOD13Q1\n[MODIS](https://terra.nasa.gov/about/terra-instruments/modis) product,\nwhich we introduced in our [last post](../2024-08-01-ndvi-data).\nHowever, instead of working with just 2 time points, this time we'll\nwork with an extended time series from 2003-2021. Because of this long\nrange, we've restricted our spatial regions of interest to reduce file\nsize. We'll work with the regions around Nairobi, Kenya and Ouagadougou,\nBurkina Faso.\n\n## Obtaining data from NASA\n\nTo simplify things, we've gone ahead and prepared these NDVI time series\nas we described in our [previous post](../2024-08-01-ndvi-data) and\nsaved them as stand-alone .tif files. We won't show the step-by-step\nprocess for producing these files, but they track closely with the\nmethods shown in our previous post, so take a look there if you need a\nrefresher on how to ingest MODIS NDVI data into R.\n\nSince our data are stored in .tif files, we can load them directly with\n`{terra}`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load NDVI time series\n# Nairobi region\nndvi_nairobi <- rast(\"data_local/ndvi_nairobi.tif\")\n\n# Ouagadougou region\nndvi_ouaga <- rast(\"data_local/ndvi_ouaga.tif\")\n```\n:::\n\n\n\n\n\n## DHS cluster coordinates\n\nIn this post, we'll be aggregating our NDVI raster data to the DHS\ncluster level as we've [demonstrated\nbefore](../2024-02-04-dhs-chirps/#summarize-precipitation-values). To do\nso, we'll need the cluster coordinate data provided by the DHS. We can\nuse `{sf}` to load the DHS cluster coordinates once we've downloaded the\nshapefiles provided by the DHS Program.\n\n::: column-margin\nIf you need a refresher on where you can access cluster coordinate data,\nsee our [CHIRPS\npost](../2024-02-04-dhs-chirps/#dhs-cluster-coordinates).\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load DHS cluster coordinates\n# KE 2014 coordinates\nke_gps <- st_read(\"data/KEGE71FL/KEGE71FL.shp\", quiet = TRUE)\n\n# BF 2010 coordinates\nbf_gps <- st_read(\"data/BFGE61FL/BFGE61FL.shp\", quiet = TRUE)\n```\n:::\n\n\n\n\n\nSince we're only working with the two capital regions for this\ndemonstration, we'll filter our cluster coordinate data to remove\nrecords for clusters that are outside each region of interest.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter Kenya cluster locations to those in the Nairobi region\nnairobi_gps <- ke_gps |>\n  filter(DHSREGNA == \"Nairobi\")\n```\n:::\n\n\n\n\n\nFor Burkina Faso, we'll also need to remove some clusters that do not\nhave valid coordinate locations, so we'll filter out cases with (0, 0)\ncoordinates:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter Burkina Faso cluster locations to those in the Ouagadougou region\nouaga_gps <- bf_gps |>\n  filter(\n    !(LATNUM == 0 & LONGNUM == 0), # Remove missing coordinate locations\n    DHSREGNA == \"Centre\"\n  )\n```\n:::\n\n\n\n\n\nEven though we're working with urban areas, our DHS clusters are still\nlocated across a range of NDVI values. Here we see our cluster point\nlocations overlaid on the NDVI raster for the region:\n\n\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# We have converted our NDVI palette from the previous post to a scale function\n# for easier use in this post\nndvi_pal <- function() {\n  list(\n    pal = c(\n      \"#fdfbdc\",\n      \"#f1f4b7\",\n      \"#d3ef9f\",\n      \"#a5da8d\",\n      \"#6cc275\",\n      \"#51a55b\",\n      \"#397e43\",\n      \"#2d673a\",\n      \"#1d472e\"\n    ),\n    values = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 1)\n  )\n}\n\nscale_fill_ndvi <- function(pal = ndvi_pal(), ...) {\n  scale_fill_gradientn(colors = pal$pal, values = pal$values, ...)\n}\n\nscale_color_ndvi <- function(pal = ndvi_pal(), ...) {\n  scale_color_gradientn(colors = pal$pal, values = pal$values, ...)\n}\n\nggplot() +\n  layer_spatial(ndvi_nairobi[[3]]) +\n  # layer_spatial(nairobi_gps, color = \"white\", alpha = 1) +\n  layer_spatial(nairobi_gps, color = \"black\", fill = \"white\", alpha = 0.9, shape = 21, size = 1.5, stroke = 1) +\n  scale_fill_ndvi(limits = c(0, 1), na.value = \"transparent\") +\n  labs(\n    title = \"2014 DHS Cluster Coordinates: Nairobi\",\n    subtitle = \"With NDVI from February 2-18, 2003\",\n    fill = \"NDVI\"\n  ) +\n  theme_dhs_map()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=100%}\n:::\n:::\n\n\n\n\n\n## Buffer cluster coordinates\n\nAs we've shown [before](../2024-02-04-dhs-chirps/#cluster-buffers), the\nnext step is to create a buffer around each cluster point location to\nget a polygon containing the general region around each cluster.\n\nWe'll first project our cluster points and then create a buffer with\n`st_buffer()`. Then, we'll project our buffered points to the same\ncoordinate reference system as our NDVI data to prepare to aggregate our\nNDVI data to our newly-created buffer regions.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Project and buffer Nairobi clusters\nnairobi_gps_buff <- nairobi_gps |>\n  st_transform(crs = 32637) |> # UTM Zone 37N\n  st_buffer(dist = 5000) |>\n  st_transform(crs = crs(ndvi_nairobi))\n\n# Project and buffer Ouagadougou clusters\nouaga_gps_buff <- ouaga_gps |>\n  st_transform(crs = 32630) |> # UTM Zone 30N\n  st_buffer(dist = 5000) |>\n  st_transform(crs = crs(ndvi_ouaga))\n```\n:::\n\n\n\n\n\n# NDVI spatial aggregation\n\nAt this point, we have everything we need to produce a single time\nseries for each cluster region.\n\n## Basic approach\n\n[Previously](../2024-02-04-dhs-chirps/#aggregating-rainfall-within-cluster-regions),\nwe introduced terra's `extract()`, which will allow us to use the NDVI\nraster along with our buffered cluster polygons to spatially aggregate\nthe NDVI pixels within each cluster region. For instance, to extract the\naverage NDVI value within each buffer, we could use `fun = mean` as\nshown below (note that we've set `na.rm = TRUE` to exclude missing\nvalues from the calculation):\n\n\n\n\n\n::: {.cell out.lines='5'}\n\n```{.r .cell-code}\n# Extract mean NDVI in each cluster buffer region:\nke_mean_ndvi <- extract(\n  ndvi_nairobi,\n  nairobi_gps_buff,\n  weights = TRUE,\n  fun = mean,\n  na.rm = TRUE # Exclude missing raster values in average\n)\n\nke_mean_ndvi\n#>    ID \"250m 16 days NDVI\" \"250m 16 days NDVI\" \"250m 16 days NDVI\"\n#> 1   1           0.6577829           0.6587233           0.5955906\n#> 2   2           0.6517902           0.6471524           0.5866545\n#> 3   3           0.6726900           0.6747525           0.6094023\n#> 4   4           0.7095437           0.7192108           0.6485346\n....\n```\n:::\n\n\n\n\n\nThis gives us a tabular record where each row corresponds to a cluster\nand each column to the mean NDVI value in that cluster buffer region for\na particular time point.\n\nHowever, our interest in NDVI is primarily as a measure for agricultural\nproduction, and some areas aren't intended to be used for agriculture\n(like water bodies or dense urban environments). Including these\nlow-NDVI pixels in our aggregation serves to reduce the mean NDVI value\nin a cluster, even if the available *agricultural* land in that cluster\nis highly productive.\n\nIf we want an estimate of the agricultural productivity of the vegetated\nland in an area, we likely want to remove very low NDVI values (which\ntypically represent impervious surfaces and water) from our calculation.\nBelow, we'll detail a few approaches that could accomplish this goal.\n\n## Idea 1: Mask out sub-zero NDVI values\n\nRecall that NDVI can range from -1 to 1, where values near and below 0\ntypically represent water or bare soil. Some of these low NDVI values in\nour raster are already treated as `NA`. Using our approach from above\n(with `na.rm = TRUE`), these are removed from consideration during\naggregation. However, pixels that border these regions may still have\nlow NDVI values. We can set these to `NA` manually using terra's\n`classify()`.\n\n`classify()` takes an input matrix that defines the range of values in\nour raster that should be reclassified. In this case, we create a matrix\ncalled `subzero_to_na` that defines the range of values from `-Inf` to\n`0`. The third value in this matrix indicates the output value for all\nraster cells that fall within this range.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubzero_to_na <- matrix(c(-Inf, 0, NA), nrow = 1)\n\nsubzero_to_na\n#>      [,1] [,2] [,3]\n#> [1,] -Inf    0   NA\n```\n:::\n\n\n\n\n\nWe can use this matrix with our NDVI raster to reclassify sub-zero NDVI\nvalues to `NA`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi_nairobi <- classify(ndvi_nairobi, subzero_to_na)\n```\n:::\n\n\n\n\n\nNow, as long as we continue to use `na.rm = TRUE` in our call to\n`extract()`, we'll automatically ignore these low NDVI values.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nke_mean_ndvi <- extract(\n  ndvi_nairobi,\n  nairobi_gps_buff,\n  weights = TRUE,\n  fun = mean,\n  na.rm = TRUE # Exclude missing raster values in average\n)\n```\n:::\n\n\n\n\n\n## Idea 2: Use maximum NDVI\n\nCrops are often grown in localized areas, so even if a large portion of\na cluster region contains low vegetation values, the crop-producing\nregions may still be thriving.\n\nFor instance, let's take an example cluster from the Ouagadougou area.\nIf we plot the NDVI values in its vicinity over the course of the year,\nwe notice a few obvious patterns.\n\n\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\nlibrary(patchwork)\n\nx <- ouaga_gps_buff[8, ]\nndvi_clust <- crop(ndvi_ouaga, x)\n\npanels <- purrr::map(\n  1:23,\n  function(i) {\n    ggplot() +\n      layer_spatial(mask(ndvi_clust[[i]], x, inverse = TRUE), alpha = 0.2) +\n      layer_spatial(mask(ndvi_clust[[i]], x)) +\n      layer_spatial(x, fill = NA, color = \"black\") +\n      scale_fill_ndvi(\n        limits = c(0, 1),\n        na.value = \"transparent\"\n      ) +\n      labs(fill = \"NDVI\")\n  }\n)\n\npurrr::reduce(panels, `+`) +\n  plot_annotation(title = \"2003 NDVI\", subtitle = \"Single Cluster: 2010 Burkina Faso Sample\") +\n  plot_layout(guides = \"collect\")  &\n  theme_void() +\n  theme_dhs_map() +\n  theme(\n    legend.position = \"bottom\",\n    legend.title.position = \"top\",\n    legend.title = element_text(size = 10, hjust = 0.5),\n    legend.key.height = unit(7, \"points\"),\n    legend.key.width = unit(45, \"points\"),\n    legend.ticks = element_line(color = \"white\", linewidth = 0.2),\n    legend.ticks.length = unit(1, \"points\"),\n    legend.frame = element_rect(\n      fill = NA,\n      color = \"#999999\",\n      linewidth = 0.2\n    ),\n    plot.title = element_text(\n      hjust = 0,\n      size = 18, \n      color = \"#00263A\", # IPUMS navy\n      margin = margin(b = 7)\n    ), \n    plot.subtitle = element_text(\n      size = 12, \n      hjust = 0,\n      color = \"#00000099\",\n      margin = margin(b = 10)\n    ),\n    plot.caption = element_text(\n      size = 10,\n      hjust = 1,\n      color = \"#00000099\",\n      margin = margin(t = 5)\n    ),\n    text = element_text(family = \"cabrito\", size = 10), \n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=100%}\n:::\n:::\n\n\n\n\n\nFirst, we notice that the overall region has a period of higher\nvegetation in the middle of the year. We also notice that there is a\nsmall area in the north of the cluster region that has consistently\nhigher vegetation than its surrounding area throughout the year, even in\ntimes with less vegetation overall.\n\nThis could be a result of water proximity (we notice that some missing\nvalues appear near the green patch, which could have been removed\nbecause they represent a water source), but it could also be because of\n**human interaction**, like irrigation.\n\nThis human element is an important feature of NDVI that distinguishes it\nfrom other environmental metrics, like precipitation and temperature.\nVegetation is more directly influenced by human behavior than these\nother sources.\n\nWhether this particular pattern is prompted primarily by physical\ngeography (a nearby water source) or human behavior (irrigation), it\ndoes serve as an example of why calculating a mean NDVI value may not\nreflect the lived experience on the ground. If most of an area's crops\nare grown in a particular area, the most critical portion of a cluster\nregion may have very high vegetation values, even if the rest of the\ncluster does not.\n\nOne option to incorporate this into our data processing would be to use\nthe *maximum* NDVI value as this cluster's value rather than the mean.\nThis is easily done in R: we just need to change our aggregation\nfunction from `fun = mean` to `fun = max`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reclassify low NDVI values\nndvi_ouaga <- classify(ndvi_ouaga, subzero_to_na)\n\nbf_max_ndvi <- extract(\n  ndvi_ouaga,\n  ouaga_gps_buff,\n  weights = TRUE,\n  fun = max, # Extract max value within cluster, not mean\n  na.rm = TRUE\n)\n```\n:::\n\n\n\n\n\nThis gives us a similarly formatted output, but each value now\nrepresents the maximum NDVI pixel value in a given cluster (row) for a\ngiven time point (column):\n\n\n\n\n\n::: {.cell out.lines='5'}\n\n```{.r .cell-code}\nbf_max_ndvi\n#>    ID \"250m 16 days NDVI\" \"250m 16 days NDVI\" \"250m 16 days NDVI\"\n#> 1   1              0.4393              0.3828              0.3759\n#> 2   2              0.4320              0.4590              0.3903\n#> 3   3              0.6664              0.4498              0.4392\n#> 4   4              0.4393              0.3828              0.3759\n....\n```\n:::\n\n\n\n\n\n### Comparing maximum and mean aggregation\n\nUsing the maximum cluster region NDVI value (rather than the mean) will\nobviously provide a different NDVI estimate for each cluster, but how\nmuch of a difference does this decision make overall?\n\nFirst, let's extract the **mean** NDVI values for our Ouagadougou\nclusters as we did earlier for Nairobi:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbf_mean_ndvi <- extract(\n  ndvi_ouaga,\n  ouaga_gps_buff,\n  weights = TRUE,\n  fun = mean,\n  na.rm = TRUE\n)\n```\n:::\n\n\n\n\n\nNow we can compare our maximum and mean NDVI values for each cluster. In\nthe plot below, each line corresponds to a DHS cluster, with the lower\npoints showing the mean NDVI value for that cluster and the higher\npoints representing the max NDVI value for that cluster (for a single\ndate):\n\n\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\ncolnames(bf_max_ndvi) <- c(\"ID\", as.character(time(ndvi_ouaga)))\ncolnames(bf_mean_ndvi) <- c(\"ID\", as.character(time(ndvi_ouaga)))\n\nbf_max_ndvi <- bf_max_ndvi |>\n  tidyr::pivot_longer(-ID) |>\n  mutate(name = as.Date(name)) |>\n  rename(time = name)\n\nbf_mean_ndvi <- bf_mean_ndvi |>\n  tidyr::pivot_longer(-ID) |>\n  mutate(name = as.Date(name)) |>\n  rename(time = name)\n\nfull_join(bf_max_ndvi, bf_mean_ndvi, by = c(\"ID\", \"time\")) |>\n  mutate(d = value.x - value.y) |>\n  filter(time == \"2003-01-01\") |>\n  ggplot() +\n  geom_segment(aes(x = reorder(ID, d), y = value.x, yend = value.y), linewidth = 0.5, color = \"gray20\", alpha = 0.8) +\n  geom_point(aes(x = reorder(ID, d), y = value.x, fill = value.x), size = 2.5, shape = 21) +\n  geom_point(aes(x = reorder(ID, d), y = value.y, fill = value.y), size = 2.5, shape = 21) +\n  annotate(\"segment\", x = 33.6, xend = 27.8, y = 0.68, yend = 0.88, color = \"gray80\") +\n  annotate(\"segment\", x = 19.2, xend = 24, y = 0.45, yend = 0.88, color = \"gray80\") +\n  geom_label(\n    x = 26,\n    y = 0.89,\n    label = \"Cluster Max NDVI\",\n    color = \"gray60\",\n    label.size = 0,\n    label.padding = unit(0.35, \"lines\"),\n    label.r = unit(0.5, \"lines\"),\n    alpha = 0.3,\n    size = 4,\n    family = \"cabrito\"\n  ) +\n  annotate(\"segment\", x = 9, xend = 7.05, y = 0.06, yend = 0.18, color = \"gray80\") +\n  annotate(\"segment\", x = 14.7, xend = 20.85, y = 0.06, yend = 0.135, color = \"gray80\") +\n  geom_label(\n    x = 12,\n    y = 0.04,\n    label = \"Cluster Mean NDVI\",\n    color = \"gray60\",\n    label.size = 0,\n    label.padding = unit(0.35, \"lines\"),\n    label.r = unit(0.5, \"lines\"),\n    alpha = 0.3,\n    size = 4,\n    family = \"cabrito\"\n  ) +\n  scale_fill_ndvi(limits = c(0, 1), guide = \"none\") +\n  lims(y = c(0, 1)) +\n  labs(\n    title = \"Difference in Maximum and Mean NDVI\",\n    subtitle = \"2010 DHS Clusters: Ouagadougou Region\",\n    x = \"DHS cluster (ordered by difference)\",\n    y = \"NDVI\"\n  ) +\n  theme(\n    axis.text.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.y = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/listing-img-1.png){width=100%}\n:::\n:::\n\n\n\n\n\nAcross clusters, we see some variability in how much of a difference the\naggregation function makes. That is, some clusters have a mean that\nclosely resembles the cluster maximum, while other clusters show more of\na difference. This could be an indication of\n\nWe can also see that there is much more variability in maximum NDVI\nvalues than mean NDVI values, which may help draw out relationships\nbetween NDVI and other health outcomes. When measuring with mean NDVI,\nall the clusters had nearly the same NDVI value!\n\n::: callout-note\nRemember that this example uses clusters exclusively from the capital\nregion. Because of the overlap in their buffer areas, we would expect\ntheir NDVI values (especially their mean values) to be highly\ncorrelated.\n\nIf we included clusters from across the country, we'd likely see far\nmore variability in these results, even for mean values.\n:::\n\nOf course, this approach also has its pitfalls. For instance, a single\npixel with an outlying NDVI value may inflate the overall aggregated\nNDVI value for an entire cluster region.\n\n### Idea 2.5: Quantile aggregation\n\nAs an alternative, it's also possible to get the NDVI value at a certain\n*percentile* of a given cluster's pixel values. That is, we could get\nthe NDVI value that represents the 95th percentile of all NDVI values in\na given cluster. In R, we can do this with the `quantile()` function.\n\nRecall that `extract()` allows us to provide an [anonymous\nfunction](../2024-04-15-chirts-metrics/index.html#scaling-up) to its\n`fun` argument. We can use `quantile()` with the `0.95` probability\nlevel (for instance) to get the 95th percentile NDVI value for each\ncluster:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextract(\n  ndvi_ouaga,\n  ouaga_gps_buff,\n  fun = function(x) quantile(x, 0.95, na.rm = TRUE)\n)\n```\n:::\n\n\n\n\n\nCalculating the quantile for a cluster may mitigate the effect of\noutliers, but because NDVI pixels are correlated with one another (that\nis, pixels with high NDVI values will disproportionately be located next\nto other pixels with high values), it's not unusual to observe several\npixels near the maximum value in a cluster. In these cases, a quantile\napproach may not produce a significant difference from using the\nmaximum.\n\n## Idea 3: A relative measure\n\nBecause NDVI is an index, its values don't have any intrinsic units\n(what does it really mean when we see an NDVI value of 0.6, for\nexample?). This means that NDVI is often easier to interpret when\nconsidered *relative* to past NDVI values in a given location. Instead\nof aggregating NDVI directly, we can compare each pixel to its prior\nvalues over the course of many years. These long-run comparisons are\ncalled **normals**.\n\nTo demonstrate, imagine we wanted to calculate the deviation from normal\nNDVI we observed in 2021. First, we'll split our final year of data\n(2021) from the rest of the time series:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split 2021 data from the rest of our data for demonstration\nis_2021 <- year(time(ndvi_nairobi)) == 2021\n\nndvi_nairobi_2021 <- ndvi_nairobi[[is_2021]]\nndvi_nairobi_comp <- ndvi_nairobi[[!is_2021]]\n```\n:::\n\n\n\n\n\nRemember that our NDVI data are recorded on 16-day intervals; we can\nsimplify by calculating the mean *monthly* NDVI for 2021 and for the\nrest of the series:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi_nairobi_2021 <- tapp(ndvi_nairobi_2021, fun = mean, index = \"months\")\nndvi_nairobi_comp <- tapp(ndvi_nairobi_comp, fun = mean, index = \"months\")\n```\n:::\n\n\n\n\n\n::: column-margin\nWe first introduced terra's `tapp()` in our [CHIRTS\npost](../2024-04-15-chirts-metrics/index.html#average-monthly-temperature).\n:::\n\nNow our 2021 data and our comparison data are both measured at the\nmonthly level. We can simply subtract them to get the monthly deviation\nof 2021's NDVI values from the long-run normal NDVI for each pixel:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi_dev <- ndvi_nairobi_2021 - ndvi_nairobi_comp\n```\n:::\n\n\n\n\n\nRecall that subtracting two rasters in terra will operate\nlayer-by-layer. This means that we will correctly subtract each month of\n2021 from the corresponding average *for that month* in the 18-year\nmonthly average raster.\n\n\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\n# Helper to split raster layers into a list for small-multiple panel mapping\nsplit_raster <- function(r) {\n  purrr::map(seq_len(nlyr(r)), function(i) r[[i]])\n}\n\n# Function to build individual panels for a small-multiple map using \n# continuous color scheme\nndvi_panel_continuous <- function(x, \n                                  panel_title = \"\",\n                                  show_scale = TRUE,\n                                  ...) {\n  ggplot() + \n    layer_spatial(x, alpha = 1, na.rm = TRUE) +\n    labs(subtitle = panel_title, fill = \"NDVI Deviation\") +\n    scale_fill_gradient2(\n      low = \"#724b00\",\n      mid = \"#f1f1f1\",\n      high = \"#00673f\",\n      na.value = \"transparent\",\n      ...\n    ) +\n    theme_dhs_map(show_scale = show_scale) +\n    theme(\n      axis.text.x = element_blank(), \n      axis.text.y = element_blank(),\n      plot.subtitle = element_text(hjust = 0.5, size = 12),\n      panel.grid = element_blank()\n    )\n}\n\n# Split raster by layer\nr <- split_raster(ndvi_dev)\n\n# Panel labels\nmonths <- c(\"January\", \"February\", \"March\", \"April\", \n            \"May\", \"June\", \"July\", \"August\",\n            \"September\", \"October\", \"November\", \"December\")\n\n# Create map panels\npanels <- purrr::map2(\n  r, \n  months,\n  function(x, y) ndvi_panel_continuous(\n    x, \n    y, \n    show_scale = FALSE,\n    n.breaks = 8, \n    limits = c(-0.6, 0.6)\n  )\n)\n\n# Plot\nwrap_plots(panels) +\n  plot_layout(guides = \"collect\", ncol = 4) +\n  plot_annotation(\n    title = \"Deviation from 18-Year Normal NDVI\",\n    subtitle = \"Nairobi region, 2021\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=100%}\n:::\n:::\n\n\n\n\n\nThis approach gives us a sense of whether certain parts of the year were\nmore or less vegetated than normal. Depending on when periods of\nabnormally low vegetation occur, they could be an indicator of poor food\nproduction.\n\nAs before, we could proceed to aggregate these values to our DHS\nclusters with `extract()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextract(\n  ndvi_dev,\n  nairobi_gps_buff,\n  weights = TRUE,\n  fun = mean,\n  na.rm = TRUE\n)\n```\n:::\n\n\n\n\n\n------------------------------------------------------------------------\n\nNote that this is by no means an exhaustive list of aggregation\ntechniques you might use with NDVI data. By demonstrating several\npossible options, our goal is to emphasize that selecting an appropriate\nmethod is a process of evaluating its relative advantages and\ndisadvantages in the context of your overall research.\n\n# Introducing seasonality\n\nSo far, we've been discussing ways to aggregate data spatially to get a\nsingle value for each DHS cluster. As we've covered\n[previously](../2024-04-15-chirts-metrics/index.html#a-new-approach),\nthough, we also need to consider how to aggregate data over time.\n\nSeasonal changes figure prominently into our understanding of how NDVI\nmay reflect conditions for people living in a given area. Certain staple\ncrops are likely grown in a particular part of the season, so higher\nNDVI during that time range may be a better indication of food access\nthan at other times of the year. Similarly, we may not be concerned\nabout low NDVI values at times of year when crops aren't typically grown\nin the first place.\n\nWe can see this reflected in the time series of mean NDVI values for\neach of our Ouagadougou cluster regions below. An obvious cyclical\npattern appears each year:\n\n\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\ndates <- c(unique(bf_mean_ndvi$time), \"2022-01-01\")\ndates <- as.numeric(dates[which(mday(dates) == 1 & month(dates) == 1)])\n\nggplot(bf_mean_ndvi) +\n  ggforce::geom_link2(aes(x = time, y = value, group = ID, color = value), n = 30, alpha = 0.3) +\n  geom_vline(xintercept = dates, alpha = 0.5, linetype = \"dashed\") +\n  scale_color_ndvi(guide = \"none\") +\n  labs(title = \"NDVI: Ouagadougou Region\", subtitle = \"2010 DHS Cluster Locations\", y = \"Mean Cluster NDVI\") +\n  ylim(c(0, 1)) +\n  theme(panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_line(linewidth = 0.7, linetype = \"dotted\"),\n        axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=100%}\n:::\n:::\n\n\n\n\n\nHowever, other areas (like Nairobi) show a lot more variability:\n\n\n\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show plot code\"}\ncolnames(ke_mean_ndvi) <- c(\"ID\", as.character(time(ndvi_nairobi)))\n\nke_mean_ndvi <- ke_mean_ndvi |>\n  tidyr::pivot_longer(-ID) |>\n  mutate(name = as.Date(name)) |>\n  rename(time = name)\n\ndates <- c(unique(ke_mean_ndvi$time), \"2022-01-01\")\ndates <- as.numeric(dates[which(mday(dates) == 1 & month(dates) == 1)])\n\nggplot(ke_mean_ndvi) +\n  ggforce::geom_link2(aes(x = time, y = value, group = ID, color = value), n = 30, alpha = 0.3) +\n  geom_vline(xintercept = dates, alpha = 0.5, linetype = \"dashed\") +\n  scale_color_ndvi(guide = \"none\") +\n  labs(title = \"NDVI: Nairobi Region\", subtitle = \"2014 DHS Cluster Locations\", y = \"Mean Cluster NDVI\") +\n  ylim(c(0, 1)) +\n  theme(panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_line(linewidth = 0.7, linetype = \"dotted\"),\n        axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=100%}\n:::\n:::\n\n\n\n\n\nIn the future, we'll spend some time exploring how we can further adjust\nour spatial data processing to incorporate this idea of seasonality!\n\n## Getting Help {.appendix}\n\nQuestions or comments? Check out the [IPUMS User\nForum](https://forum.ipums.org) or reach out to IPUMS User Support at\nipums\\@umn.edu.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}